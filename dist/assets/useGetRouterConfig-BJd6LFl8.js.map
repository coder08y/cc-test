{"version":3,"file":"useGetRouterConfig-BJd6LFl8.js","sources":["../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/cloneDeep.js","../../src/hooks/swap/useSwapRouter.ts","../../src/components/swap/ScamsAlert.tsx","../../src/components/swap/SwapRoutes/OverView.tsx","../../src/components/swap/V3Router.tsx","../../src/components/swap/SwapRoutes/RoutesModal.tsx","../../src/hooks/swap/useGetRouterConfig.ts"],"sourcesContent":["import baseClone from './_baseClone.js';\n\n/** Used to compose bitmasks for cloning. */\nvar CLONE_DEEP_FLAG = 1,\n    CLONE_SYMBOLS_FLAG = 4;\n\n/**\n * This method is like `_.clone` except that it recursively clones `value`.\n *\n * @static\n * @memberOf _\n * @since 1.0.0\n * @category Lang\n * @param {*} value The value to recursively clone.\n * @returns {*} Returns the deep cloned value.\n * @see _.clone\n * @example\n *\n * var objects = [{ 'a': 1 }, { 'b': 2 }];\n *\n * var deep = _.cloneDeep(objects);\n * console.log(deep[0] === objects[0]);\n * // => false\n */\nfunction cloneDeep(value) {\n  return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);\n}\n\nexport default cloneDeep;\n","import useSwapStore from '@/store/swap/swap'\nimport { useGetToken } from '@cetus/hooks/src/useToken'\nimport { CoinType } from '@cetus/types'\nimport { adjustTo100, d, fixDown, toLongCoinType } from '@cetus/utils'\nimport { Path } from '@cetusprotocol/aggregator-sdk'\nimport { useDeepCompareEffect } from 'ahooks'\nimport { useState } from 'react'\n\nexport type TilePathItem = Path & {\n  pathIndex: number\n  routeIndex: number\n  stepsFromEnd: number\n}\n\n// 节点数据结构\ntype Node = {\n  id: string\n  top: number\n  left: number\n  width: number\n  height: number\n  columnIndex: number\n}\n\n// 边数据结构\ntype Edge = {\n  from: string\n  to: string\n  fromX: number\n  fromY: number\n  toX: number\n  toY: number\n  fromPercent: string\n  isStart?: boolean\n  segments?: {\n    x1: number\n    y1: number\n    x2: number\n    y2: number\n  }[]\n}\n\nconst routerComWidth = 878\nconst blockWidth = 176\nconst blockGap = 72\nconst gapWithLine = 22 // 同一列块儿距离路径线的距离\nconst blockPadding = 8 // 要考虑上下左右\nconst columeBlockSpace = 16 // 一列中块之间的上下距离\nconst targetCoinInfoHeight = 24 // 每个块儿里target icon和symbol展示区域的高度\nconst fromToTargetBlockPaddingTopAndBottom = 12\nconst fromToTargetBlockPaddingLeftAndRight = 8\nconst fromToTargetTitleHeight = 16\nconst fromToTargetMrTop = 8\nconst providerRowHeight = 22 // 设计图上只有12，因为不想用间距控制，直接把高度算高一点\n// const minTop = 117\nconst minTop = 50\nconst zStartWidth = 55 // Z字形连线水平偏移距离\nconst routerComGap = 13\nconst pathToGap = 5\n\nexport function useSwapRouter(routerData?: any, originFromCoinType?: string, originToCoinType?: string) {\n  // const { fetchTokenInfo } = useGetToken()\n  const [newFormatSwapRouter, setNewFormatSwapRouter] = useState<any>({})\n  const [nodes, setgNodes] = useState<any>([])\n  const [edges, setEdges] = useState<any>([])\n  const [panelHeight, setPanelHeight] = useState<number>(0)\n  const { fromCoin, toCoin } = useSwapStore()\n  const [allProviders, setAllProviders] = useState<string[]>([])\n  const [resultColumes, setResultColumes] = useState<any[][]>([])\n\n  // 新的优化方法：根据最大深度合理分配路径和列结构\n  function getNodeColumeOptimized(paths: any[], fromCoinType: string, targetCoinType: string, maxDepth: number = 3): any[][] {\n    console.log('🔍 getNodeColumeOptimized 开始')\n    console.log('🔍 fromCoinType:', fromCoinType)\n    console.log('🔍 targetCoinType:', targetCoinType)\n    console.log('🔍 maxDepth:', maxDepth)\n\n    // 收集所有唯一的节点\n    const allNodes = new Set<string>()\n    paths.forEach((path: any) => {\n      allNodes.add(path.from)\n      allNodes.add(path.target)\n    })\n\n    console.log('🔍 所有节点:', Array.from(allNodes))\n\n    // 按层级分配节点\n    const columns: any[][] = []\n\n    // 第0列：从fromCoinType出发的节点\n    const column0: any[] = []\n    const firstColNodes = new Set<string>()\n\n    paths.forEach((path: any) => {\n      if (path.from === fromCoinType && path.target !== targetCoinType) {\n        const target = path.target\n\n        // 检查除了fromCoinType之外，是否还有其他节点到达这个target\n        const hasOtherFroms = paths.some((otherPath: any) => otherPath.target === target && otherPath.from !== fromCoinType)\n        let notCollectInfirst = false\n        if (hasOtherFroms) {\n          const allTargets = new Set(paths.filter((otherPath: any) => otherPath.from === target)?.map((item: any) => item?.target))\n          const allTargetsArray = Array.from(allTargets)\n          const allTargetsArrayOnlyEqualTargetCoinType = allTargetsArray.every((item: any) => item === targetCoinType)\n          if (allTargetsArrayOnlyEqualTargetCoinType) {\n            notCollectInfirst = true\n          }\n        }\n\n        // 如果所有到达这个target的节点都是targetCoinType，则不放入第一列\n        if (!notCollectInfirst) {\n          firstColNodes.add(target)\n        }\n      }\n    })\n\n    // 为第一列节点收集路径\n    firstColNodes.forEach(target => {\n      const fromGroups: Record<string, any[]> = {}\n\n      paths.forEach((path: any) => {\n        if (path.from === fromCoinType && path.target === target) {\n          if (!fromGroups[fromCoinType]) {\n            fromGroups[fromCoinType] = []\n          }\n          fromGroups[fromCoinType].push(path)\n        }\n      })\n\n      // 对每个 fromGroups 中的数组按 provider 和 feeRate 合并\n      Object.keys(fromGroups).forEach(fromKey => {\n        const providerFeeRateMap = new Map<string, any>()\n\n        fromGroups[fromKey].forEach(path => {\n          const provider = path.provider\n          const feeRate = path.feeRate\n          const key = `${provider}_${feeRate}`\n\n          if (providerFeeRateMap.has(key)) {\n            // 如果已存在相同 provider 和 feeRate，累加 amountIn 和 amountOut\n            const existing = providerFeeRateMap.get(key)\n            existing.amountIn = d(existing.amountIn)\n              .plus(path.amountIn || '0')\n              .toString()\n            existing.amountOut = d(existing.amountOut)\n              .plus(path.amountOut || '0')\n              .toString()\n          } else {\n            // 如果不存在，直接添加\n            providerFeeRateMap.set(key, {\n              ...path,\n              amountIn: path.amountIn || '0',\n              amountOut: path.amountOut || '0'\n            })\n          }\n        })\n\n        // 将合并后的数据转换回数组\n        fromGroups[fromKey] = Array.from(providerFeeRateMap.values())\n      })\n\n      column0.push({\n        target: `0-${target}`,\n        originalTarget: target,\n        list: fromGroups\n      })\n    })\n\n    if (column0.length > 0) {\n      columns.push(column0)\n      console.log('🔍 添加第0列，数据数量:', column0.length)\n    }\n\n    // 第1列：中间节点（既不是fromCoinType也不是targetCoinType）\n    const column1: any[] = []\n    const middleNodes = new Set<string>()\n\n    paths.forEach((path: any) => {\n      if (path.from !== fromCoinType && path.from !== targetCoinType) {\n        middleNodes.add(path.from)\n      }\n      if (path.target !== fromCoinType && path.target !== targetCoinType) {\n        middleNodes.add(path.target)\n      }\n    })\n\n    // 为中间列节点收集路径\n    middleNodes.forEach(node => {\n      const fromGroups: Record<string, any[]> = {}\n      paths.forEach((path: any) => {\n        if (path.target === node) {\n          // 如果from是fromCoinType，需要检查这个节点是否在第一列\n          if (path.from === fromCoinType) {\n            // 如果这个节点不在第一列，才收集这个路径\n            if (!firstColNodes.has(node)) {\n              if (!fromGroups[path.from]) {\n                fromGroups[path.from] = []\n              }\n              fromGroups[path.from].push(path)\n            }\n          } else {\n            // 如果from不是fromCoinType，直接收集\n            if (!fromGroups[path.from]) {\n              fromGroups[path.from] = []\n            }\n            fromGroups[path.from].push(path)\n          }\n        }\n      })\n\n      if (Object.keys(fromGroups).length > 0) {\n        // 对每个 fromGroups 中的数组按 provider 和 feeRate 合并\n        Object.keys(fromGroups).forEach(fromKey => {\n          const providerFeeRateMap = new Map<string, any>()\n\n          fromGroups[fromKey].forEach(path => {\n            const provider = path.provider\n            const feeRate = path.feeRate\n            const key = `${provider}_${feeRate}`\n\n            if (providerFeeRateMap.has(key)) {\n              // 如果已存在相同 provider 和 feeRate，累加 amountIn 和 amountOut\n              const existing = providerFeeRateMap.get(key)\n              existing.amountIn = d(existing.amountIn)\n                .plus(path.amountIn || '0')\n                .toString()\n              existing.amountOut = d(existing.amountOut)\n                .plus(path.amountOut || '0')\n                .toString()\n            } else {\n              // 如果不存在，直接添加\n              providerFeeRateMap.set(key, {\n                ...path,\n                amountIn: path.amountIn || '0',\n                amountOut: path.amountOut || '0'\n              })\n            }\n          })\n\n          // 将合并后的数据转换回数组\n          fromGroups[fromKey] = Array.from(providerFeeRateMap.values())\n        })\n\n        column1.push({\n          target: `1-${node}`,\n          originalTarget: node,\n          list: fromGroups\n        })\n      }\n    })\n\n    if (column1.length > 0) {\n      columns.push(column1)\n      console.log('🔍 添加第1列，数据数量:', column1.length)\n    }\n\n    // 第2列：targetCoinType\n    const column2: any[] = []\n    const targetFromGroups: Record<string, any[]> = {}\n\n    paths.forEach((path: any) => {\n      if (path.target === targetCoinType) {\n        if (!targetFromGroups[path.from]) {\n          targetFromGroups[path.from] = []\n        }\n        targetFromGroups[path.from].push(path)\n      }\n    })\n\n    if (Object.keys(targetFromGroups).length > 0) {\n      // 对每个 targetFromGroups 中的数组按 provider 和 feeRate 合并\n      Object.keys(targetFromGroups).forEach(fromKey => {\n        const providerFeeRateMap = new Map<string, any>()\n\n        targetFromGroups[fromKey].forEach(path => {\n          const provider = path.provider\n          const feeRate = path.feeRate\n          const key = `${provider}_${feeRate}`\n\n          if (providerFeeRateMap.has(key)) {\n            // 如果已存在相同 provider 和 feeRate，累加 amountIn 和 amountOut\n            const existing = providerFeeRateMap.get(key)\n            existing.amountIn = d(existing.amountIn)\n              .plus(path.amountIn || '0')\n              .toString()\n            existing.amountOut = d(existing.amountOut)\n              .plus(path.amountOut || '0')\n              .toString()\n          } else {\n            // 如果不存在，直接添加\n            providerFeeRateMap.set(key, {\n              ...path,\n              amountIn: path.amountIn || '0',\n              amountOut: path.amountOut || '0'\n            })\n          }\n        })\n\n        // 将合并后的数据转换回数组\n        targetFromGroups[fromKey] = Array.from(providerFeeRateMap.values())\n      })\n\n      column2.push({\n        target: `2-${targetCoinType}`,\n        originalTarget: targetCoinType,\n        list: targetFromGroups\n      })\n    }\n\n    if (column2.length > 0) {\n      columns.push(column2)\n      console.log('🔍 添加第2列，数据数量:', column2.length)\n    }\n\n    // 如果列数大于2，进行额外处理\n    // if (columns.length > 2) {\n    //   console.log('🔍 列数大于2，开始处理第一列节点')\n\n    //   const firstCol = columns[0] || []\n    //   const secondCol = columns[1] || []\n    //   const thirdCol = columns[2] || []\n\n    //   // 找到第三列的目标节点\n    //   const thirdColTarget = thirdCol[0]?.originalTarget || thirdCol[0]?.target\n\n    //   if (thirdColTarget) {\n    //     // 遍历第一列节点，检查哪些需要移动到第二列\n    //     const nodesToMove: any[] = []\n    //     const nodesToKeep: any[] = []\n\n    //     firstCol.forEach((node: any) => {\n    //       const originalTarget = node.originalTarget || node.target\n\n    //       // 检查该节点是否只到达第三列的一个节点\n    //       const outgoingPaths = paths.filter((path: any) => path.from === originalTarget)\n    //       const onlyReachesThirdCol = outgoingPaths.length === 1 && outgoingPaths[0].target === thirdColTarget\n\n    //       if (onlyReachesThirdCol) {\n    //         console.log(`🔍 节点 ${originalTarget} 只到达第三列，移动到第二列`)\n    //         nodesToMove.push(node)\n    //       } else {\n    //         console.log(`🔍 节点 ${originalTarget} 保持在第一列`)\n    //         nodesToKeep.push(node)\n    //       }\n    //     })\n\n    //     // 更新第一列和第二列\n    //     if (nodesToMove.length > 0) {\n    //       // 更新第一列，只保留不需要移动的节点\n    //       columns[0] = nodesToKeep\n    //       console.log(`🔍 第一列保留 ${nodesToKeep.length} 个节点`)\n\n    //       // 将需要移动的节点添加到第二列\n    //       columns[1] = [...secondCol, ...nodesToMove]\n    //       console.log(`🔍 第二列新增 ${nodesToMove.length} 个节点`)\n    //     }\n    //   }\n    // }\n\n    return columns\n  }\n\n  // 4. 生成画布需要的节点数据，包含到时候div定位的位置top, left和div的高度height和width(with是固定的)\n  function getNodes(nodeColume: any, fromCoinType: string, paths: any[]) {\n    const columeNum = nodeColume.length\n    const columeComWidth = columeNum * blockWidth + (columeNum - 1) * blockGap\n    const columeComMarginWithRouterCom = (routerComWidth - columeComWidth) / 2\n\n    const nodesMap = new Map<string, Node>()\n    const orderedNodeColume: any[][] = []\n\n    // 1. 首先计算每个节点的height\n    const nodeHeights = new Map<string, number>()\n    nodeColume.forEach((col: any, colIndex: number) => {\n      col.forEach((block: any) => {\n        const nodeKey = `${colIndex}-${block.target}`\n        const height = getBlockHeight(block.list)\n        console.log(`node高度, nodeKey=${nodeKey}, height=${height}`)\n        nodeHeights.set(nodeKey, height)\n      })\n    })\n\n    // 2. 根据列数采用不同的布局策略\n    if (columeNum === 1) {\n      // 情况1: 只有1列，上下左右居中放置\n      console.log('🔍 情况1: 只有1列')\n      const col = nodeColume[0]\n      let currentTop = minTop\n\n      col.forEach((block: any) => {\n        const nodeKey = `0-${block.target}`\n        const blockHeight = nodeHeights.get(nodeKey) || 0\n\n        nodesMap.set(nodeKey, {\n          ...block,\n          id: nodeKey,\n          top: currentTop,\n          left: columeComMarginWithRouterCom,\n          height: blockHeight,\n          width: blockWidth,\n          columnIndex: 0\n        })\n\n        console.log(`🔍 放置单列节点 ${block.target}: top=${currentTop}`)\n        currentTop += blockHeight + columeBlockSpace\n      })\n\n      orderedNodeColume.push(col)\n    } else if (columeNum === 2) {\n      // 情况2: 只有2列\n      console.log('🔍 情况2: 只有2列')\n\n      const firstCol = nodeColume[0]\n      const secondCol = nodeColume[1]\n\n      // 检查是否有fromCoinType直接到第二列\n      const hasFromCoinToSecondCol = secondCol.some((secondBlock: any) => {\n        return secondBlock.list && secondBlock.list[fromCoinType]\n      })\n\n      // 第一列：按amountIn降序排序\n      const sortedFirstCol = firstCol\n        .map((block: any) => {\n          const totalAmountIn = block.list[fromCoinType]?.reduce((sum: number, item: any) => sum + parseFloat(item.amountIn || '0'), 0) || 0\n          return { block, totalAmountIn }\n        })\n        .sort((a: any, b: any) => b.totalAmountIn - a.totalAmountIn)\n        .map(({ block }: { block: any; totalAmountIn: number }) => block)\n\n      // 放置第一列\n      let currentTop = hasFromCoinToSecondCol ? minTop + gapWithLine : minTop\n      sortedFirstCol.forEach((block: any) => {\n        const nodeKey = `0-${block.target}`\n        const blockHeight = nodeHeights.get(nodeKey) || 0\n\n        nodesMap.set(nodeKey, {\n          ...block,\n          id: nodeKey,\n          top: currentTop,\n          left: columeComMarginWithRouterCom,\n          height: blockHeight,\n          width: blockWidth,\n          columnIndex: 0\n        })\n\n        console.log(`🔍 放置第一列节点 ${block.target}: top=${currentTop}`)\n        currentTop += blockHeight + columeBlockSpace\n      })\n\n      // 第二列：从minTop开始\n      let secondColTop = minTop\n      secondCol.forEach((block: any) => {\n        const nodeKey = `1-${block.target}`\n        const blockHeight = nodeHeights.get(nodeKey) || 0\n\n        nodesMap.set(nodeKey, {\n          ...block,\n          id: nodeKey,\n          top: secondColTop,\n          left: columeComMarginWithRouterCom + blockWidth + blockGap,\n          height: blockHeight,\n          width: blockWidth,\n          columnIndex: 1\n        })\n\n        console.log(`🔍 放置第二列节点 ${block.target}: top=${secondColTop}`)\n        secondColTop += blockHeight + columeBlockSpace\n      })\n\n      orderedNodeColume.push(sortedFirstCol, secondCol)\n    } else {\n      // 情况3: 有三列\n      console.log('🔍 情况3: 有三列')\n\n      const firstCol = nodeColume[0]\n      const secondCol = nodeColume[1]\n      const thirdCol = nodeColume[2]\n      const targetCoinType = thirdCol[0]?.originalTarget || thirdCol[0]?.target\n\n      // 确定第一列的顺序\n      const firstColAnalysis = firstCol.map((block: any) => {\n        const target = block.originalTarget || block.target\n        const nodeKey = `0-${block.target}`\n        const height = nodeHeights.get(nodeKey) || 0\n\n        // 检查是否有直接到targetCoinType的连接\n\n        const secondColHaveEqualTarget = secondCol.some((secondBlock: any) => {\n          return secondBlock.originalTarget == block.originalTarget\n        })\n\n        const hasDirectToTarget = thirdCol?.[0]?.list?.[block?.originalTarget] && !secondColHaveEqualTarget\n\n        // 检查是否有到第二列的连接\n        const hasConnectionToSecond = secondCol.some((secondBlock: any) => {\n          const secondTarget = secondBlock.originalTarget || secondBlock.target\n          return paths.some((path: any) => {\n            return path.from === target && path.target === secondTarget\n          })\n        })\n\n        // 检查第二列目标节点是否只有这一个from\n        const secondColTargets: string[] = []\n        secondCol.forEach((secondBlock: any) => {\n          const secondTarget = secondBlock.originalTarget || secondBlock.target\n          if (paths.some((path: any) => path.from === target && path.target === secondTarget)) {\n            secondColTargets.push(secondTarget)\n          }\n        })\n\n        // 计算优先级\n        let priority = 6\n        if (hasDirectToTarget && !hasConnectionToSecond) {\n          priority = 1 // 只到最后一列（最高优先级）\n        } else if (hasDirectToTarget && hasConnectionToSecond) {\n          priority = 2 // 既到最后一列节点，也到第二列节点的\n        } else if (!hasDirectToTarget && hasConnectionToSecond) {\n          if (secondColTargets.length === 1) {\n            const singleTarget = secondColTargets[0]\n            const secondBlock = secondCol.find((block: any) => {\n              const secondTarget = block.originalTarget || block.target\n              return secondTarget === singleTarget\n            })\n            const currentColFromCount = secondBlock ? Object.keys(secondBlock.list || {}).length : 0\n\n            if (currentColFromCount === 1) {\n              priority = 3 // 只到第二列，且只到一个节点，且到达节点只有这一个from\n            } else {\n              priority = 5 // 只到第二列节点，且只到这一个节点的，但到达节点有多个from\n            }\n          } else {\n            // 检查所有到达的节点是否都只有一个from\n            const allTargetsHaveSingleFrom = secondColTargets.every((target: string) => {\n              const secondBlock = secondCol.find((block: any) => {\n                const secondTarget = block.originalTarget || block.target\n                return secondTarget === target\n              })\n              const currentColFromCount = secondBlock ? Object.keys(secondBlock.list || {}).length : 0\n              return currentColFromCount === 1\n            })\n\n            if (allTargetsHaveSingleFrom) {\n              priority = 4 // 只到第二列节点，且到多个节点，且到达的所有节点只有这一个from\n            } else {\n              priority = 6 // 其他情况\n            }\n          }\n        }\n\n        return {\n          block,\n          target,\n          height,\n          hasDirectToTarget,\n          hasConnectionToSecond,\n          secondColTargets,\n          priority\n        }\n      })\n\n      // 按优先级排序第一列\n      firstColAnalysis.sort((a: any, b: any) => {\n        if (a.priority !== b.priority) {\n          return a.priority - b.priority\n        }\n        // 优先级相同时，按amountIn排序\n        const aAmountIn = a.block.list[fromCoinType]?.reduce((sum: number, item: any) => sum + parseFloat(item.amountIn || '0'), 0) || 0\n        const bAmountIn = b.block.list[fromCoinType]?.reduce((sum: number, item: any) => sum + parseFloat(item.amountIn || '0'), 0) || 0\n        return bAmountIn - aAmountIn\n      })\n\n      // 检查是否有fromCoinType直接到targetCoinType\n      const hasFromCoinToTarget = thirdCol.some((thirdBlock: any) => {\n        const thirdTarget = thirdBlock.originalTarget || thirdBlock.target\n        return thirdTarget === targetCoinType && thirdBlock.list && thirdBlock.list[fromCoinType]\n      })\n\n      const hasFromCoinToSecondCol = secondCol.some((secondBlock: any) => {\n        return secondBlock.list && secondBlock.list[fromCoinType]\n      })\n\n      // 确定第一列起始位置\n      let firstColStartTop = hasFromCoinToTarget ? minTop + gapWithLine : minTop // 因为有三列且有fromCoinType到targetCoinType\n\n      // 如果有fromCoinType到第二列节点，且该节点只有一个from，则加上该节点的高度和间距\n      if (hasFromCoinToSecondCol) {\n        const fromCoinSecondColBlock = secondCol.find((secondBlock: any) => {\n          return secondBlock.list && secondBlock.list[fromCoinType]\n        })\n\n        if (fromCoinSecondColBlock) {\n          const fromCount = Object.keys(fromCoinSecondColBlock.list || {}).length\n          if (fromCount === 1) {\n            // 该节点只有一个from，加上其高度和间距\n            const secondBlockKey = `1-${fromCoinSecondColBlock.target}`\n            const secondBlockHeight = nodeHeights.get(secondBlockKey) || 0\n            firstColStartTop += secondBlockHeight + columeBlockSpace\n          } else {\n            firstColStartTop += gapWithLine\n          }\n        }\n      }\n\n      // 特殊处理：如果fromCoinType直接到第二列节点，且第一列的第一个节点有直接到第三列节点\n      if (hasFromCoinToSecondCol && firstColAnalysis.length > 0) {\n        const firstNode = firstColAnalysis[0]\n        if (firstNode.hasDirectToTarget && firstColStartTop <= minTop + gapWithLine) {\n          console.log('🔍 检测到特殊情况：fromCoinType直接到第二列，且第一列第一个节点直接到第三列')\n          firstColStartTop += 50 // 在原有基础上再加50\n          console.log(`🔍 第一列起始位置调整为: ${firstColStartTop}`)\n        } else {\n          firstColStartTop += columeBlockSpace\n        }\n      }\n\n      // 放置第一列\n      let currentColume1Top = firstColStartTop\n      firstColAnalysis.forEach((item: any, index: number) => {\n        const nodeKey = `0-${item.block.target}`\n        const blockHeight = nodeHeights.get(nodeKey) || 0\n\n        nodesMap.set(nodeKey, {\n          ...item.block,\n          id: nodeKey,\n          top: currentColume1Top,\n          left: columeComMarginWithRouterCom,\n          height: blockHeight,\n          width: blockWidth,\n          columnIndex: 0\n        })\n\n        console.log(`🔍 放置第一列节点 ${item.target}: top=${currentColume1Top}`)\n\n        // 计算下一个节点的位置\n        if (index < firstColAnalysis.length - 1) {\n          // 第一列节点依次放置，只加上当前节点高度和间距\n          currentColume1Top += blockHeight + columeBlockSpace\n        }\n      })\n\n      // 确定第二列的顺序\n      const secondColOrder: any[] = []\n\n      // 从from等于fromCoinType的放在第一个\n      const fromCoinSecondCol = secondCol.find((block: any) => {\n        return block.list && block.list[fromCoinType]\n      })\n      if (fromCoinSecondCol) {\n        secondColOrder.push(fromCoinSecondCol)\n      }\n\n      // 其他根据第一列每个节点到达第二列情况排序\n      firstColAnalysis.forEach((firstItem: any) => {\n        firstItem.secondColTargets.forEach((secondTarget: string) => {\n          const secondBlock = secondCol.find((block: any) => {\n            return (block.originalTarget || block.target) === secondTarget\n          })\n          if (secondBlock && !secondColOrder.some(item => item.target === secondBlock.target)) {\n            secondColOrder.push(secondBlock)\n          }\n        })\n      })\n\n      // 添加第一列没有连接到的第二列节点\n      secondCol.forEach((secondBlock: any) => {\n        const secondTarget = secondBlock.originalTarget || secondBlock.target\n        if (!secondColOrder.some(item => (item.originalTarget || item.target) === secondTarget)) {\n          secondColOrder.push(secondBlock)\n        }\n      })\n\n      // 确定第二列起始位置\n      let secondColStartTop = hasFromCoinToTarget ? minTop + gapWithLine : minTop\n\n      // 检查第一列是否有节点既到第二列也直接到最后一列\n      const hasFirstColToBoth = firstColAnalysis.some((item: any) => {\n        return item.hasDirectToTarget && item.hasConnectionToSecond\n      })\n\n      if (hasFirstColToBoth) {\n        // 如果第一列有节点既到第二列也直接到最后一列，第二列多留出gapWithLine距离\n        secondColStartTop += gapWithLine\n      }\n\n      // 判断第一列是否有直接到最后一列的\n      const hasFirstColToTargetNum = firstColAnalysis.filter((item: any) => {\n        return item.hasDirectToTarget && !item.hasConnectionToSecond\n      })?.length\n\n      // 放置第二列\n      let currentColume2Top = secondColStartTop\n      secondColOrder.forEach((block: any, index: number) => {\n        const nodeKey = `1-${block.target}`\n        const blockHeight = nodeHeights.get(nodeKey) || 0\n        if (index === 0 && hasFirstColToTargetNum > 0) {\n          if (!hasFromCoinToSecondCol) {\n            currentColume2Top += hasFirstColToTargetNum * 120 + hasFirstColToTargetNum * columeBlockSpace\n          } else {\n            currentColume2Top += gapWithLine\n          }\n        }\n\n        nodesMap.set(nodeKey, {\n          ...block,\n          id: nodeKey,\n          top: currentColume2Top,\n          left: columeComMarginWithRouterCom + blockWidth + blockGap,\n          height: blockHeight,\n          width: blockWidth,\n          columnIndex: 1\n        })\n\n        console.log(`🔍 放置第二列节点 ${block.originalTarget || block.target}: top=${currentColume2Top}  blockHeight=${blockHeight}`)\n        currentColume2Top += blockHeight + columeBlockSpace\n      })\n\n      // 放置第三列\n      let currentColume3Top = minTop\n      thirdCol.forEach((block: any) => {\n        const nodeKey = `2-${block.target}`\n        const blockHeight = nodeHeights.get(nodeKey) || 0\n\n        nodesMap.set(nodeKey, {\n          ...block,\n          id: nodeKey,\n          top: currentColume3Top,\n          left: columeComMarginWithRouterCom + 2 * blockWidth + 2 * blockGap,\n          height: blockHeight,\n          width: blockWidth,\n          columnIndex: 2\n        })\n\n        console.log(`🔍 放置第三列节点 ${block.target}: top=${currentColume3Top}`)\n        currentColume3Top += blockHeight + columeBlockSpace\n      })\n\n      orderedNodeColume.push(\n        firstColAnalysis.map((item: any) => item.block),\n        secondColOrder,\n        thirdCol\n      )\n    }\n\n    return { nodesMap, orderedNodeColume }\n  }\n\n  // 根据nodeColume重新生成正确的百分比数据\n  function generateNodePercentages(nodeColume: any[], paths: any[], fromCoinType: string) {\n    console.log('🚀 ~ generateNodePercentages ~ nodeColume:', nodeColume)\n    const nodePercentages: Record<string, Record<string, { fromPercent: string }>> = {}\n\n    // 1. 先处理fromCoinType的百分比\n\n    // 收集所有列中list里存在fromCoinType为key的数据\n    const fromCoinTypeTargets: { target: string; amountIn: number; colIndex: number }[] = []\n\n    nodeColume.forEach((col, colIndex) => {\n      col.forEach((block: any) => {\n        const originalTarget = block.originalTarget || block.target\n        if (block.list && block.list[fromCoinType]) {\n          const totalAmountIn = block.list[fromCoinType].reduce((sum: number, item: any) => {\n            return sum + parseFloat(item.amountIn || '0')\n          }, 0)\n          fromCoinTypeTargets.push({\n            target: originalTarget,\n            amountIn: totalAmountIn,\n            colIndex\n          })\n        }\n      })\n    })\n\n    console.log('🔍 fromCoinType的目标:', fromCoinTypeTargets)\n\n    if (fromCoinTypeTargets.length > 0) {\n      const totalFromAmountIn = fromCoinTypeTargets.reduce((sum, item) => sum + item.amountIn, 0)\n\n      // 先计算原始百分比\n      const rawPercents: number[] = []\n      fromCoinTypeTargets.forEach(({ amountIn }) => {\n        const rawPercent = totalFromAmountIn > 0 ? fixDown(d(amountIn).div(totalFromAmountIn).mul(100).toString(), 0) : 0\n        rawPercents.push(Number(rawPercent) || 1)\n      })\n\n      const rawAjuestPercents = adjustTo100(rawPercents)\n\n      fromCoinTypeTargets.forEach(({ target }, index) => {\n        const fromPercent = rawAjuestPercents[index]?.toString() || '0'\n\n        if (!nodePercentages[fromCoinType]) {\n          nodePercentages[fromCoinType] = {}\n        }\n        nodePercentages[fromCoinType][target] = { fromPercent }\n\n        console.log(`🔍 设置fromCoinType百分比: ${fromCoinType} -> ${target}: ${fromPercent}%`)\n      })\n    }\n\n    // 2. 处理第一列节点的百分比\n    if (nodeColume.length > 0) {\n      const firstCol = nodeColume[0]\n      console.log('🔍 处理第一列节点的百分比')\n\n      firstCol.forEach((block: any) => {\n        const originalTarget = block.originalTarget || block.target\n        const nodeKey = `0-${originalTarget}`\n\n        console.log(`🔍 处理第一列节点: ${originalTarget}`)\n\n        // 收集所有目标\n        const allTargets: { target: string; amountIn: number }[] = []\n\n        // 1. 检查第二列是否有节点的originalTarget等于当前第一列节点的originalTarget\n        let hasSameTargetInSecondCol = false\n        if (nodeColume.length > 1) {\n          const secondCol = nodeColume[1]\n          hasSameTargetInSecondCol = secondCol.some((secondBlock: any) => {\n            const secondTarget = secondBlock.originalTarget || secondBlock.target\n            return secondTarget === originalTarget\n          })\n        }\n\n        // 2. 如果第二列有相同的originalTarget，只检查第二列\n        if (hasSameTargetInSecondCol) {\n          const secondCol = nodeColume[1]\n          secondCol.forEach((secondBlock: any) => {\n            const secondTarget = secondBlock.originalTarget || secondBlock.target\n            if (secondBlock.list && secondBlock.list[originalTarget]) {\n              const totalAmountIn = secondBlock.list[originalTarget].reduce((sum: number, item: any) => {\n                return sum + parseFloat(item.amountIn || '0')\n              }, 0)\n              allTargets.push({\n                target: secondTarget,\n                amountIn: totalAmountIn\n              })\n            }\n          })\n        } else {\n          // 3. 如果第二列没有相同的originalTarget，检查后面所有列\n          for (let colIndex = 1; colIndex < nodeColume.length; colIndex++) {\n            const currentCol = nodeColume[colIndex]\n            currentCol.forEach((block: any) => {\n              const blockTarget = block.originalTarget || block.target\n              if (block.list && block.list[originalTarget]) {\n                const totalAmountIn = block.list[originalTarget].reduce((sum: number, item: any) => {\n                  return sum + parseFloat(item.amountIn || '0')\n                }, 0)\n                allTargets.push({\n                  target: blockTarget,\n                  amountIn: totalAmountIn\n                })\n              }\n            })\n          }\n        }\n\n        console.log(`🔍 ${originalTarget} 的所有目标:`, allTargets)\n\n        if (allTargets.length > 0) {\n          const totalAmountIn = allTargets.reduce((sum, item) => sum + item.amountIn, 0)\n\n          // 先计算原始百分比\n          const rawPercents: number[] = []\n          allTargets.forEach(({ amountIn }) => {\n            const rawPercent = totalAmountIn > 0 ? fixDown(d(amountIn).div(totalAmountIn).mul(100).toString(), 0) : 0\n            rawPercents.push(Number(rawPercent) || 1)\n          })\n\n          const rawAjuestPercents = adjustTo100(rawPercents)\n\n          allTargets.forEach(({ target }, index) => {\n            const fromPercent = rawAjuestPercents[index]\n\n            if (!nodePercentages[nodeKey]) {\n              nodePercentages[nodeKey] = {}\n            }\n            nodePercentages[nodeKey][target] = { fromPercent: fromPercent.toString() }\n\n            console.log(`🔍 设置第一列节点百分比: ${originalTarget} -> ${target}: ${fromPercent}%`)\n          })\n        }\n      })\n    }\n\n    // 3. 处理第二列节点的百分比（如果有第三列的话）\n    if (nodeColume.length > 2) {\n      const secondCol = nodeColume[1]\n      console.log('🔍 处理第二列节点的百分比')\n\n      secondCol.forEach((block: any) => {\n        const originalTarget = block.originalTarget || block.target\n        const nodeKey = `1-${originalTarget}`\n\n        console.log(`🔍 处理第二列节点: ${originalTarget}`)\n\n        // 检查第三列\n        const thirdColTargets: { target: string; amountIn: number }[] = []\n        const thirdCol = nodeColume[2]\n        thirdCol.forEach((thirdBlock: any) => {\n          const thirdTarget = thirdBlock.originalTarget || thirdBlock.target\n          if (thirdBlock.list && thirdBlock.list[originalTarget]) {\n            const totalAmountIn = thirdBlock.list[originalTarget].reduce((sum: number, item: any) => {\n              return sum + parseFloat(item.amountIn || '0')\n            }, 0)\n            thirdColTargets.push({\n              target: thirdTarget,\n              amountIn: totalAmountIn\n            })\n          }\n        })\n\n        console.log(`🔍 ${originalTarget} 在第三列的目标:`, thirdColTargets)\n\n        if (thirdColTargets.length > 0) {\n          const totalAmountIn = thirdColTargets.reduce((sum, item) => sum + item.amountIn, 0)\n\n          // 先计算原始百分比\n          const rawPercents: number[] = []\n          thirdColTargets.forEach(({ amountIn }) => {\n            const rawPercent = totalAmountIn > 0 ? fixDown(d(amountIn).div(totalAmountIn).mul(100).toString(), 0) : 0\n            rawPercents.push(Number(rawPercent) || 1)\n          })\n\n          const rawAjuestPercents = adjustTo100(rawPercents)\n\n          thirdColTargets.forEach(({ target }, index) => {\n            const fromPercent = rawAjuestPercents[index]\n\n            if (!nodePercentages[nodeKey]) {\n              nodePercentages[nodeKey] = {}\n            }\n            nodePercentages[nodeKey][target] = { fromPercent: fromPercent.toString() }\n\n            console.log(`🔍 设置第二列节点百分比: ${originalTarget} -> ${target}: ${fromPercent}%`)\n          })\n        }\n      })\n    }\n\n    return nodePercentages\n  }\n\n  // 辅助方法：根据列索引和coinType查找节点\n  function findNodeByColumnAndCoinType(colIndex: number, coinType: string, nodesMap: Map<string, any>): any {\n    for (const [key, node] of nodesMap.entries()) {\n      if (key.startsWith(`${colIndex}-`) && (node.originalTarget === coinType || node.target === coinType)) {\n        return node\n      }\n    }\n    return null\n  }\n\n  function getEdges(nodePercentages: any, nodesMap: Map<string, any>, fromCoinType: string, nodeColume: any[], paths: any[]) {\n    const edges: {\n      from: string\n      to: string\n      fromX: number\n      fromY: number\n      toX: number\n      toY: number\n      fromPercent: string\n      isStart?: boolean\n      isFinal?: boolean\n      segments?: any[]\n    }[] = []\n\n    console.log('🔍 开始生成连接线')\n\n    // 1. 先确定fromCoinType出发的线\n    console.log('🔍 处理fromCoinType出发的线')\n\n    // 1.1 从fromCoinType到targetCoinType的线\n    const targetCoinType = nodeColume[nodeColume.length - 1]?.[0]?.originalTarget || nodeColume[nodeColume.length - 1]?.[0]?.target\n    if (targetCoinType) {\n      const targetNode = findNodeByColumnAndCoinType(nodeColume.length - 1, targetCoinType, nodesMap)\n\n      if (targetNode) {\n        const fromPercent = nodePercentages[fromCoinType]?.[targetCoinType]?.fromPercent || '0'\n\n        // 检查是否有fromCoinType直接到targetCoinType的路径\n        const hasDirectPath =\n          nodeColume.length > 0 &&\n          nodeColume[nodeColume.length - 1].some((lastBlock: any) => {\n            const lastTarget = lastBlock.originalTarget || lastBlock.target\n            return lastTarget === targetCoinType && lastBlock.list && lastBlock.list[fromCoinType]\n          })\n\n        // 只有当有直接路径时才生成这条线\n        if (hasDirectPath) {\n          // 检查是否是单列情况（只有一列，且只有一个节点）\n          const isSingleColumn = nodeColume.length === 1 && nodeColume[0].length === 1\n\n          if (isSingleColumn) {\n            // 单列情况：到达节点的中心位置\n            edges.push({\n              from: fromCoinType,\n              to: targetNode.id,\n              fromX: routerComGap,\n              fromY: targetNode.top + targetNode.height / 2,\n              toX: targetNode.left - pathToGap,\n              toY: targetNode.top + targetNode.height / 2,\n              fromPercent,\n              isStart: true\n            })\n            console.log(`🔍 添加fromCoinType到targetCoinType的线（单列）: ${fromPercent}%`)\n          } else {\n            // 多列情况：使用固定的跨列位置\n            edges.push({\n              from: fromCoinType,\n              to: targetNode.id,\n              fromX: routerComGap,\n              fromY: minTop + 10,\n              toX: targetNode.left - pathToGap,\n              toY: minTop + 10,\n              fromPercent,\n              isStart: true\n            })\n            console.log(`🔍 添加fromCoinType到targetCoinType的线（跨列）: ${fromPercent}%`)\n          }\n        } else {\n          console.log(`🔍 跳过fromCoinType到targetCoinType的线，因为fromPercent为0`)\n        }\n      }\n    }\n\n    // 1.2 从fromCoinType到其他列的线（排除targetCoinType，因为已经在1.1中处理了）\n    for (let colIndex = 0; colIndex < nodeColume.length; colIndex++) {\n      const currentCol = nodeColume[colIndex]\n\n      currentCol.forEach((block: any) => {\n        const originalTarget = block.originalTarget || block.target\n        const currentNode = findNodeByColumnAndCoinType(colIndex, originalTarget, nodesMap)\n\n        if (!currentNode) return\n\n        // 检查是否有fromCoinType到当前节点的连接\n        const hasFromCoinConnection = block.list && block.list[fromCoinType]\n        if (!hasFromCoinConnection) return\n\n        // 跳过targetCoinType，因为已经在1.1中处理了\n        if (originalTarget === targetCoinType) return\n\n        const fromPercent = nodePercentages[fromCoinType]?.[originalTarget]?.fromPercent || '0'\n\n        // 1.3 列数大于2，从fromCoinType到第二列节点的处理\n        if (nodeColume.length > 2 && colIndex === 1) {\n          const fromCount = Object.keys(block.list || {}).length\n\n          if (fromCount === 1) {\n            // 到达节点只有这一个from\n            edges.push({\n              from: fromCoinType,\n              to: currentNode.id,\n              fromX: routerComGap,\n              fromY: currentNode.top + currentNode.height / 2,\n              toX: currentNode.left - pathToGap,\n              toY: currentNode.top + currentNode.height / 2,\n              fromPercent,\n              isStart: true\n            })\n          } else {\n            // 到达节点有多个不同from\n            edges.push({\n              from: fromCoinType,\n              to: currentNode.id,\n              fromX: routerComGap,\n              fromY: currentNode.top + 10,\n              toX: currentNode.left - pathToGap,\n              toY: currentNode.top + 10,\n              fromPercent,\n              isStart: true\n            })\n          }\n        } else {\n          // 1.4 其他fromCoinType到第一列的线\n          edges.push({\n            from: fromCoinType,\n            to: currentNode.id,\n            fromX: routerComGap,\n            fromY: currentNode.top + currentNode.height / 2,\n            toX: currentNode.left - pathToGap,\n            toY: currentNode.top + currentNode.height / 2,\n            fromPercent,\n            isStart: true\n          })\n        }\n\n        console.log(`🔍 添加fromCoinType到${originalTarget}的线: ${fromPercent}%`)\n      })\n    }\n\n    // 2. 确定节点到节点的线\n    console.log('🔍 处理节点到节点的线')\n\n    // 为同一个节点的多条出发线分配不同的Y坐标\n    const nodeOutgoingCounts = new Map<string, number>()\n    const nodeOutgoingIndices = new Map<string, number>()\n\n    // 先统计每个节点的出发线数量\n    for (let colIndex = 0; colIndex < nodeColume.length; colIndex++) {\n      const currentCol = nodeColume[colIndex]\n\n      currentCol.forEach((block: any) => {\n        const originalTarget = block.originalTarget || block.target\n        const currentNode = findNodeByColumnAndCoinType(colIndex, originalTarget, nodesMap)\n\n        if (!currentNode) return\n\n        // 获取当前节点的所有from连接\n        const fromConnections = block.list || {}\n\n        Object.entries(fromConnections).forEach(([fromToken, targetData]: [string, any]) => {\n          if (fromToken === fromCoinType) return // 跳过fromCoinType的连接\n\n          // 找到fromToken对应的节点\n          let fromNode: any = null\n\n          for (let prevColIndex = colIndex - 1; prevColIndex >= 0; prevColIndex--) {\n            fromNode = findNodeByColumnAndCoinType(prevColIndex, fromToken, nodesMap)\n            if (fromNode) break\n          }\n\n          if (!fromNode) return\n\n          // 统计出发线数量\n          const fromNodeId = fromNode.id\n          const currentCount = nodeOutgoingCounts.get(fromNodeId) || 0\n          nodeOutgoingCounts.set(fromNodeId, currentCount + 1)\n        })\n      })\n    }\n\n    // 处理所有节点到节点的连接\n    for (let colIndex = 0; colIndex < nodeColume.length; colIndex++) {\n      const currentCol = nodeColume[colIndex]\n\n      currentCol.forEach((block: any) => {\n        const originalTarget = block.originalTarget || block.target\n        const currentNode = findNodeByColumnAndCoinType(colIndex, originalTarget, nodesMap)\n\n        if (!currentNode) return\n\n        // 获取当前节点的所有from连接\n        const fromConnections = block.list || {}\n\n        Object.entries(fromConnections).forEach(([fromToken, targetData]: [string, any]) => {\n          if (fromToken === fromCoinType) return // 跳过fromCoinType的连接\n\n          // 找到fromToken对应的节点\n          let fromNode: any = null\n\n          for (let prevColIndex = colIndex - 1; prevColIndex >= 0; prevColIndex--) {\n            fromNode = findNodeByColumnAndCoinType(prevColIndex, fromToken, nodesMap)\n            if (fromNode) break\n          }\n\n          if (!fromNode) return\n\n          const fromNodeId = fromNode.id\n\n          // 检查是否需要绕行连接\n          const fromCenterY = fromNode.top + fromNode.height / 2\n          let needZigzag = false\n\n          // 计算当前节点的出发线索引，用于分配不同的Y坐标\n          const currentOutgoingIndex = nodeOutgoingIndices.get(fromNodeId) || 0\n          nodeOutgoingIndices.set(fromNodeId, currentOutgoingIndex + 1)\n\n          // 特殊检查：第一列第一个节点到第三列节点的连接\n          if (nodeColume.length === 3 && fromNode.columnIndex === 0 && currentNode.columnIndex === 2) {\n            // 检查是否是第一列的第一个节点\n            const firstColFirstNode = nodeColume[0]?.[0]\n            if (\n              firstColFirstNode &&\n              (fromNode.originalTarget || fromNode.target) === (firstColFirstNode.originalTarget || firstColFirstNode.target)\n            ) {\n              // 检查是否有fromCoinType直接到第二列\n              const hasFromCoinToSecondCol =\n                nodeColume.length > 1 &&\n                nodeColume[1].some((secondBlock: any) => {\n                  return secondBlock.list && secondBlock.list[fromCoinType]\n                })\n\n              // 只有当同时有fromCoinType直接到第三列和第二列时，才进行特殊处理\n              if (hasFromCoinToSecondCol) {\n                console.log('特殊处理：第一列第一个节点到第三列节点，强制使用特殊路径')\n                needZigzag = true\n              } else {\n                console.log('第一列第一个节点到第三列节点，使用普通水平连接')\n                needZigzag = false\n                // 直接生成水平连接线\n                const fromPercent =\n                  nodePercentages[`${fromNode.columnIndex}-${fromNode.originalTarget || fromNode.target}`]?.[originalTarget]?.fromPercent || '0'\n\n                edges.push({\n                  from: fromNode.id,\n                  to: currentNode.id,\n                  fromX: fromNode.left + fromNode.width,\n                  fromY: fromNode.top + 10,\n                  toX: currentNode.left,\n                  toY: fromNode.top + 10,\n                  fromPercent\n                })\n              }\n            } else {\n              // 检查是否可以从fromCenterY水平到达目标节点\n              if (fromCenterY >= currentNode.top && fromCenterY <= currentNode.top + currentNode.height) {\n                // 可以直接水平连接\n                const fromPercent =\n                  nodePercentages[`${fromNode.columnIndex}-${fromNode.originalTarget || fromNode.target}`]?.[originalTarget]?.fromPercent || '0'\n\n                edges.push({\n                  from: fromNode.id,\n                  to: currentNode.id,\n                  fromX: fromNode.left + fromNode.width,\n                  fromY: fromCenterY,\n                  toX: currentNode.left - pathToGap,\n                  toY: fromCenterY,\n                  fromPercent\n                })\n              } else {\n                // 检查当前节点范围内是否有可以水平连接的位置\n                let foundHorizontalPosition = false\n                for (let y = fromNode.top; y <= fromNode.top + fromNode.height; y += 5) {\n                  if (y >= currentNode.top && y <= currentNode.top + currentNode.height) {\n                    const fromPercent =\n                      nodePercentages[`${fromNode.columnIndex}-${fromNode.originalTarget || fromNode.target}`]?.[originalTarget]?.fromPercent || '0'\n\n                    edges.push({\n                      from: fromNode.id,\n                      to: currentNode.id,\n                      fromX: fromNode.left + fromNode.width,\n                      fromY: y,\n                      toX: currentNode.left - pathToGap,\n                      toY: y,\n                      fromPercent\n                    })\n                    foundHorizontalPosition = true\n                    break\n                  }\n                }\n\n                if (!foundHorizontalPosition) {\n                  // 需要绕行连接\n                  needZigzag = true\n                }\n              }\n            }\n          } else {\n            // 其他情况：检查是否可以从fromCenterY水平到达目标节点\n            if (fromCenterY >= currentNode.top && fromCenterY <= currentNode.top + currentNode.height) {\n              // 可以直接水平连接\n              const fromPercent =\n                nodePercentages[`${fromNode.columnIndex}-${fromNode.originalTarget || fromNode.target}`]?.[originalTarget]?.fromPercent || '0'\n\n              edges.push({\n                from: fromNode.id,\n                to: currentNode.id,\n                fromX: fromNode.left + fromNode.width,\n                fromY: fromCenterY,\n                toX: currentNode.left,\n                toY: fromCenterY,\n                fromPercent\n              })\n            } else {\n              // 检查当前节点范围内是否有可以水平连接的位置\n              let foundHorizontalPosition = false\n              for (let y = fromNode.top; y <= fromNode.top + fromNode.height; y += 5) {\n                if (y > currentNode.top + 10 && y < currentNode.top + currentNode.height - 10) {\n                  const fromPercent =\n                    nodePercentages[`${fromNode.columnIndex}-${fromNode.originalTarget || fromNode.target}`]?.[originalTarget]?.fromPercent || '0'\n                  edges.push({\n                    from: fromNode.id,\n                    to: currentNode.id,\n                    fromX: fromNode.left + fromNode.width,\n                    fromY: y,\n                    toX: currentNode.left,\n                    toY: y,\n                    fromPercent\n                  })\n                  foundHorizontalPosition = true\n                  break\n                }\n              }\n\n              if (!foundHorizontalPosition) {\n                // 需要绕行连接\n                needZigzag = true\n              }\n            }\n          }\n\n          // 如果需要绕行连接，生成Z型连线\n          if (needZigzag) {\n            const fromPercent =\n              nodePercentages[`${fromNode.columnIndex}-${fromNode.originalTarget || fromNode.target}`]?.[originalTarget]?.fromPercent || '0'\n\n            // 计算出发点的Y坐标，为同一个节点的多条出发线分配不同的Y坐标\n            const totalOutgoingCount = nodeOutgoingCounts.get(fromNodeId) || 1\n            const currentOutgoingIndex = nodeOutgoingIndices.get(fromNodeId) || 0\n            const spacing = 50 // 出发线之间的间隔\n            const startY = fromNode.top + 10 // 从节点顶部+10开始\n            const availableHeight = fromNode.height - 20 // 可用高度\n            const step = totalOutgoingCount > 3 ? Math.min(spacing, availableHeight / Math.max(1, totalOutgoingCount - 1)) : spacing\n            const adjustedFromY = startY + currentOutgoingIndex * step\n\n            // 特殊处理：第一列第一个节点到第三列节点的连接\n            if (nodeColume.length === 3 && fromNode.columnIndex === 0 && currentNode.columnIndex === 2) {\n              // 检查是否是第一列的第一个节点\n              const firstColFirstNode = nodeColume[0]?.[0]\n              if (\n                firstColFirstNode &&\n                (fromNode.originalTarget || fromNode.target) === (firstColFirstNode.originalTarget || firstColFirstNode.target)\n              ) {\n                console.log('特殊处理：第一列第一个节点到第三列节点')\n\n                // 从当前节点left+width/2, top位置出发\n                const specialFromX = fromNode.left + fromNode.width / 2\n                const specialFromY = fromNode.top\n\n                edges.push({\n                  from: fromNode.id,\n                  to: currentNode.id,\n                  fromX: specialFromX,\n                  fromY: specialFromY,\n                  toX: currentNode.left,\n                  toY: minTop + 10,\n                  fromPercent,\n                  segments: [\n                    {\n                      x1: specialFromX,\n                      y1: specialFromY,\n                      x2: specialFromX,\n                      y2: minTop + 10\n                    },\n                    {\n                      x1: specialFromX,\n                      y1: minTop + 10,\n                      x2: currentNode.left - pathToGap,\n                      y2: minTop + 10\n                    }\n                  ]\n                })\n              } else {\n                // 其他第一列到第三列的连接，使用原来的逻辑\n                if (currentNode.top > fromNode.top + fromNode.height) {\n                  console.log('生成Z型连线，segments数量: 3')\n\n                  // 目标节点在下方\n                  edges.push({\n                    from: fromNode.id,\n                    to: currentNode.id,\n                    fromX: fromNode.left + fromNode.width,\n                    fromY: adjustedFromY,\n                    toX: fromNode.left + fromNode.width + zStartWidth,\n                    toY: adjustedFromY,\n                    fromPercent,\n                    segments: [\n                      {\n                        x1: fromNode.left + fromNode.width,\n                        y1: adjustedFromY,\n                        x2: fromNode.left + fromNode.width + zStartWidth,\n                        y2: adjustedFromY\n                      },\n                      {\n                        x1: fromNode.left + fromNode.width + zStartWidth,\n                        y1: adjustedFromY,\n                        x2: fromNode.left + fromNode.width + zStartWidth,\n                        y2: currentNode.top + 20\n                      },\n                      {\n                        x1: fromNode.left + fromNode.width + zStartWidth,\n                        y1: currentNode.top + 20,\n                        x2: currentNode.left,\n                        y2: currentNode.top + 20\n                      }\n                    ]\n                  })\n                  console.log('Z型连线生成完成，edge:', edges[edges.length - 1])\n                } else {\n                  // 目标节点在上方\n                  edges.push({\n                    from: fromNode.id,\n                    to: currentNode.id,\n                    fromX: fromNode.left + fromNode.width,\n                    fromY: adjustedFromY,\n                    toX: fromNode.left + fromNode.width + zStartWidth,\n                    toY: adjustedFromY,\n                    fromPercent,\n                    segments: [\n                      {\n                        x1: fromNode.left + fromNode.width,\n                        y1: adjustedFromY,\n                        x2: fromNode.left + fromNode.width + zStartWidth,\n                        y2: adjustedFromY\n                      },\n                      {\n                        x1: fromNode.left + fromNode.width + zStartWidth,\n                        y1: adjustedFromY,\n                        x2: fromNode.left + fromNode.width + zStartWidth,\n                        y2: currentNode.top + currentNode.height - 20\n                      },\n                      {\n                        x1: fromNode.left + fromNode.width + zStartWidth,\n                        y1: currentNode.top + currentNode.height - 20,\n                        x2: currentNode.left - pathToGap,\n                        y2: currentNode.top + currentNode.height - 20\n                      }\n                    ]\n                  })\n                }\n              }\n            } else {\n              // 特殊处理：三列情况下第二列到第三列的连接\n              if (nodeColume.length === 3 && fromNode.columnIndex === 1 && currentNode.columnIndex === 2 && currentNode.top < fromNode.top) {\n                console.log('三列情况：第二列到第三列，目标节点在上方')\n                console.log('三列情况：第二列到第三列，目标节点在上方from: ', fromNode.id)\n                console.log('三列情况：第二列到第三列，目标节点在上方to: ', currentNode.id)\n\n                // 从源节点中心出发，先水平到目标节点中心，然后向上到目标节点底部\n                edges.push({\n                  from: fromNode.id,\n                  to: currentNode.id,\n                  fromX: fromNode.left + fromNode.width,\n                  fromY: adjustedFromY,\n                  toX: currentNode.left + currentNode.width / 2,\n                  toY: adjustedFromY,\n                  fromPercent,\n                  segments: [\n                    {\n                      x1: fromNode.left + fromNode.width,\n                      y1: adjustedFromY,\n                      x2: currentNode.left + currentNode.width / 2,\n                      y2: adjustedFromY\n                    },\n                    {\n                      x1: currentNode.left + currentNode.width / 2,\n                      y1: adjustedFromY,\n                      x2: currentNode.left + currentNode.width / 2,\n                      y2: currentNode.top + currentNode.height + pathToGap\n                    }\n                  ]\n                })\n              } else if (currentNode.top > fromNode.top + fromNode.height) {\n                console.log('生成Z型连线，segments数量: 3')\n\n                // 目标节点在下方\n                edges.push({\n                  from: fromNode.id,\n                  to: currentNode.id,\n                  fromX: fromNode.left + fromNode.width,\n                  fromY: adjustedFromY,\n                  toX: fromNode.left + fromNode.width + zStartWidth,\n                  toY: adjustedFromY,\n                  fromPercent,\n                  segments: [\n                    {\n                      x1: fromNode.left + fromNode.width,\n                      y1: adjustedFromY,\n                      x2: fromNode.left + fromNode.width + zStartWidth,\n                      y2: adjustedFromY\n                    },\n                    {\n                      x1: fromNode.left + fromNode.width + zStartWidth,\n                      y1: adjustedFromY,\n                      x2: fromNode.left + fromNode.width + zStartWidth,\n                      y2: currentNode.top + 20\n                    },\n                    {\n                      x1: fromNode.left + fromNode.width + zStartWidth,\n                      y1: currentNode.top + 20,\n                      x2: currentNode.left - pathToGap,\n                      y2: currentNode.top + 20\n                    }\n                  ]\n                })\n              } else {\n                console.log('目标节点在上面11 fromNode: ', fromNode)\n                console.log('目标节点在上面11 currentNode: ', currentNode)\n                // 目标节点在上方\n                edges.push({\n                  from: fromNode.id,\n                  to: currentNode.id,\n                  fromX: fromNode.left + fromNode.width,\n                  fromY: adjustedFromY,\n                  toX: fromNode.left + fromNode.width + zStartWidth,\n                  toY: adjustedFromY,\n                  fromPercent,\n                  segments: [\n                    {\n                      x1: fromNode.left + fromNode.width,\n                      y1: adjustedFromY,\n                      x2: fromNode.left + fromNode.width + zStartWidth,\n                      y2: adjustedFromY\n                    },\n                    {\n                      x1: fromNode.left + fromNode.width + zStartWidth,\n                      y1: adjustedFromY,\n                      x2: fromNode.left + fromNode.width + zStartWidth,\n                      y2: currentNode.top + currentNode.height - 20\n                    },\n                    {\n                      x1: fromNode.left + fromNode.width + zStartWidth,\n                      y1: currentNode.top + currentNode.height - 20,\n                      x2: currentNode.left - pathToGap,\n                      y2: currentNode.top + currentNode.height - 20\n                    }\n                  ]\n                })\n              }\n            }\n          }\n        })\n      })\n    }\n\n    // 3. 添加最后一列出发的线\n    console.log('🔍 添加最后一列出发的线')\n    const maxColumnIndex = Math.max(...Array.from(nodesMap.values()).map(node => node.columnIndex))\n    const lastColumnNodes = Array.from(nodesMap.values()).filter(node => node.columnIndex === maxColumnIndex)\n\n    if (lastColumnNodes.length > 0) {\n      const lastColumnNode = lastColumnNodes[0]\n      const fromY = lastColumnNode.top + lastColumnNode.height / 2\n\n      edges.push({\n        from: lastColumnNode.id,\n        to: 'final',\n        fromX: lastColumnNode.left + lastColumnNode.width,\n        fromY,\n        toX: routerComWidth - routerComGap,\n        toY: fromY,\n        fromPercent: '100',\n        isFinal: true\n      })\n\n      console.log('🔍 添加最终边')\n    }\n\n    return { edges }\n  }\n\n  function getPanelHeight(nodes: { top: number; height: number }[]) {\n    if (nodes.length === 0) return 0\n    let minTop = Infinity\n    let maxBottom = -Infinity\n    nodes.forEach(node => {\n      minTop = Math.min(minTop, node.top)\n      maxBottom = Math.max(maxBottom, node.top + node.height)\n    })\n    return maxBottom - minTop\n  }\n\n  const toFormatSwapRouter = async () => {\n    const paths: any = routerData?.routerData?.paths\n\n    // console.log('🚀 ~ toFormatSwapRouter ~ paths:', JSON.stringify(paths))\n    // const paths: any = []\n\n    if (!paths || paths?.length === 0) return\n    const fromCoinType = toLongCoinType(fromCoin?.coin_type || originFromCoinType || '')\n    console.log('4444🚀 ~ toFormatSwapRouter ~ fromCoinType:', fromCoinType)\n    const targetCoinType = toLongCoinType(toCoin?.coin_type || originToCoinType || '')\n    console.log('4444🚀 ~ toFormatSwapRouter ~ targetCoinType:', targetCoinType)\n\n    // 使用优化版本的方法，确保最大深度不超过3列\n    const nodeColume = getNodeColumeOptimized(paths, fromCoinType, targetCoinType, 3)\n    console.log('🚀 ~ toFormatSwapRouter11 ~ nodeColume (优化版):', nodeColume)\n\n    const { nodesMap, orderedNodeColume } = getNodes(nodeColume, fromCoinType, paths)\n    setResultColumes(orderedNodeColume)\n\n    // 生成基于nodeColume的百分比数据\n    const nodePercentages = generateNodePercentages(orderedNodeColume, paths, fromCoinType)\n    console.log('🚀 ~ toFormatSwapRouter ~ nodePercentages:', nodePercentages)\n\n    const { edges } = getEdges(nodePercentages, nodesMap, fromCoinType, orderedNodeColume, paths)\n    const adjustedNodes = [...nodesMap.values()]\n    console.log('🚀 ~ toFormatSwapRouter ~ adjustedNodes:', adjustedNodes)\n    console.log('🚀 ~ toFormatSwapRouter11 ~ edges:', edges)\n\n    const panelHeight = getPanelHeight([...nodesMap.values()]) + minTop + 32\n\n    setPanelHeight(panelHeight)\n    setgNodes(adjustedNodes)\n    setEdges(edges)\n\n    // 从 nodeKey 中提取 originalTarget，并去重\n    const targets = Array.from(new Set([...nodesMap.values()].map((node: any) => node.originalTarget || node.target)))\n    getTokenMap([...targets, fromCoinType])\n  }\n\n  const { getTokenListInfo } = useGetToken()\n  const [tokenMap, setTokenMap] = useState<Map<string, any>>(new Map())\n\n  const getTokenMap = async (coinTypeList: string[]) => {\n    const res = await getTokenListInfo(coinTypeList as CoinType[])\n    if (res && res?.size > 0) {\n      setTokenMap(res)\n    }\n  }\n\n  useDeepCompareEffect(() => {\n    toFormatSwapRouter()\n    getAllProviders(routerData?.routerData?.paths || [])\n  }, [routerData])\n\n  // 获取所有去重的 providers\n  function getAllProviders(paths: any[]) {\n    if (!Array.isArray(paths)) return []\n\n    const providers = new Set<string>()\n    paths.forEach((path: any) => {\n      if (path.provider) {\n        providers.add(path.provider)\n      }\n    })\n\n    // return Array.from(providers)\n    setAllProviders(Array.from(providers))\n  }\n\n  // 获取target块儿信息高度\n  function getBlockHeight(list: any): number {\n    console.log('🚀 ~ getBlockHeight ~ list:', list)\n    let height = blockPadding * 2 + targetCoinInfoHeight\n    const fromEntries = Object.entries(list)\n\n    fromEntries.forEach(([from, items]: [string, any], index: number) => {\n      height += fromToTargetBlockPaddingTopAndBottom * 2\n      height += fromToTargetTitleHeight\n      height += 10 // 来源具体xx>xx标题距离\n\n      items.forEach((i: any) => {\n        height += providerRowHeight\n      })\n    })\n\n    return height + (fromEntries?.length - 1) * fromToTargetMrTop + 10\n  }\n\n  return {\n    newFormatSwapRouter,\n    nodes,\n    edges,\n    tokenMap,\n    panelHeight,\n    getAllProviders,\n    allProviders,\n    resultColumes\n  }\n}\n","import { HighlightText } from '@cetus/design'\nimport { Icon } from '@cetus/ui-kit'\nimport { Box, HStack, Text, VStack } from '@chakra-ui/react'\n\ninterface ScamsAlertProps {\n  scamsText: string\n}\nfunction ScamsAlert({ scamsText }: ScamsAlertProps) {\n  return (\n    <VStack borderRadius=\"8px\" border=\"1px solid\" borderColor=\"border\" pt=\"12px\" maxW=\"480px\">\n      <HStack>\n        <Icon xlinkHref=\"#icon-icon_priceupdated\" svgFill=\"primary_yellow\" svgHover=\"primary_yellow\" svgW=\"20px\" svgH=\"20px\" />\n        <Text color=\"primary_yellow\">Alert</Text>\n      </HStack>\n\n      <Box bg=\"card_bg\" borderRadius=\"8px\" p=\"11px\">\n        <HighlightText\n          text={`${scamsText}  detected to have Deny List feature. It's an optional feature on Sui designed for regulated coins (learn more). However, it could be misused by HoneyPot scams, which may restrict users from selling the tokens after buying. Please be cautious.`}\n          keywords={['learn more']}\n          onKeywordClick={() => {\n            window.open('https://docs.sui.io/guides/developer/coin/regulated', '_blank')\n          }}\n        />\n      </Box>\n    </VStack>\n  )\n}\n\nexport default ScamsAlert\n","import { AggregatorDexMap, findDisplayName, findGroupDex } from '@/config/aggregator'\nimport { AggregatorProvider } from '@/types/swap'\n// import { useGetToken } from '@cetus/hooks/src/useToken'\nimport useWindowWidth from '@cetus/hooks/src/useWindowWidth'\n// import { CoinType } from '@cetus/types'\nimport { SingleCoinImage } from '@cetus/ui-kit'\nimport { Box, HStack, Popover, PopoverBody, PopoverContent, PopoverTrigger, Portal, Skeleton } from '@chakra-ui/react'\nimport { useEffect, useState } from 'react'\n// import { useEffect, useState } from 'react'\n\nconst OverView = ({\n  allProviders,\n  children,\n  loading,\n  isSwapWidget\n}: {\n  allProviders?: string[]\n  children?: React.ReactNode\n  loading?: boolean\n  isSwapWidget?: boolean\n}) => {\n  const { isApp } = useWindowWidth()\n\n  const [allProviderFilter, setAllProviderFilter] = useState<AggregatorProvider[]>([])\n\n  useEffect(() => {\n    const processedGroups = new Set<string>()\n    const filteredProviders: AggregatorProvider[] = []\n\n    allProviders?.forEach(item => {\n      const groupDex = findGroupDex(item as AggregatorProvider)\n\n      if (groupDex) {\n        // 如果这个 provider 属于某个组\n        if (!processedGroups.has(groupDex.groupName)) {\n          // 如果这个组还没有被处理过，添加第一个遇到的该组 provider\n          processedGroups.add(groupDex.groupName)\n          filteredProviders.push(item as AggregatorProvider)\n        }\n        // 如果这个组已经被处理过，跳过（不添加到结果中）\n      } else {\n        // 如果这个 provider 不属于任何组，直接添加\n        filteredProviders.push(item as AggregatorProvider)\n      }\n    })\n\n    setAllProviderFilter(filteredProviders)\n  }, [allProviders])\n\n  return (\n    allProviders && (\n      <Skeleton isLoaded={!loading} minW=\"128px\" minH=\"20px\">\n        <HStack w=\"100%\" gap=\"4px\" justify=\"flex-end\" wrap=\"wrap\" minH=\"20px\" alignItems=\"center\">\n          {/* {data?.router_summery !== '1 Streams' ? (\n            <Text color=\"text_caption\" fontSize={isSwapWidget ? '12px' : '14px'} fontWeight=\"500\" overflowWrap=\"break-word\">\n              {data?.router_summery}\n            </Text>\n          ) : (\n            <>\n              <Text color=\"text_caption\" fontSize={isSwapWidget ? '12px' : '14px'} fontWeight=\"500\" textAlign=\"right\" overflowWrap=\"break-word\">\n                {data?.routers[0]?.paths\n                  ?.map((path, index) => {\n                    if (index === 0) {\n                      return `${tokenMap?.get(path?.from_type)?.symbol} > ${tokenMap?.get(path?.to_type)?.symbol}`\n                    }\n                    return tokenMap?.get(path?.to_type)?.symbol\n                  })\n                  .join(' > ')}\n              </Text>\n            </>\n          )} */}\n          {allProviderFilter?.map(item => {\n            return isApp && children ? (\n              <SingleCoinImage w=\"16px\" h=\"16px\" imageUrl={AggregatorDexMap[item]?.logo} />\n            ) : (\n              <Popover isLazy key={item} trigger={isApp ? 'click' : 'hover'}>\n                <PopoverTrigger>\n                  <Box>\n                    <SingleCoinImage w=\"16px\" h=\"16px\" imageUrl={AggregatorDexMap[item]?.logo} />\n                  </Box>\n                </PopoverTrigger>\n                <Portal>\n                  <PopoverContent w=\"unset\">\n                    <PopoverBody fontSize=\"12px\">{findDisplayName(item)}</PopoverBody>\n                  </PopoverContent>\n                </Portal>\n              </Popover>\n            )\n          })}\n          {children}\n        </HStack>\n      </Skeleton>\n    )\n  )\n}\n\nexport default OverView\n","import { AggregatorDexMap } from '@/config/aggregator'\nimport { getPercentage } from '@/utils'\nimport { AddressCopyLink, CetusTooltip } from '@cetus/design'\nimport useExplorer from '@cetus/hooks/src/useExplorer'\nimport useWindowWidth from '@cetus/hooks/src/useWindowWidth'\nimport { CoinPairImage, SingleCoinImage } from '@cetus/ui-kit'\nimport { adjustTo100, d, fixDown, formatFeeRate, textEllipses } from '@cetus/utils'\nimport { Box, Center, HStack, Popover, PopoverBody, PopoverContent, PopoverTrigger, Portal, Text, VStack } from '@chakra-ui/react'\nimport { useMemo, useRef } from 'react'\nimport { useSwapRouter } from '../../hooks/swap/useSwapRouter'\n\nconst pathStrokeWidth = 2\n\ninterface V3RouterProps {\n  data: any\n  originFromCoinType?: string\n  originToCoinType?: string\n  isWidget?: boolean\n  config?: {\n    nodeWidth?: number\n    searchStep?: number\n    nodePadding?: number\n    maxSearchDistance?: number\n    arrowOffset?: number\n  }\n}\n\nexport default function V3Router({ data, config = {}, originFromCoinType, originToCoinType, isWidget }: V3RouterProps) {\n  const { nodes, edges, tokenMap, panelHeight, resultColumes } = useSwapRouter(data, originFromCoinType, originToCoinType)\n  const containerRef = useRef<HTMLDivElement>(null)\n\n  // 默认配置\n  const defaultConfig = {\n    nodeWidth: 176,\n    searchStep: 5,\n    nodePadding: 10,\n    maxSearchDistance: 50,\n    arrowOffset: 5,\n    ...config\n  }\n\n  const displayNodes = useMemo(() => {\n    return nodes?.map((targetItem: any) => {\n      // 使用 originalTarget 来获取正确的 token 信息\n      const originalTarget = targetItem.originalTarget || targetItem.target\n      const targetInfo = tokenMap?.get(originalTarget)\n      const keys = Object.keys(targetItem?.list)\n      return {\n        ...targetItem,\n        targetSymbol: targetInfo?.symbol,\n        targetImg: targetInfo?.logo_url,\n        fromGroups: Object.values(targetItem?.list)?.map((item: any, index: number) => {\n          // 使用 keys[index] 作为 from，因为它已经是正确的 coin type\n          const fromInfo = tokenMap?.get(keys[index])\n          const title = `${textEllipses(fromInfo?.symbol || '', 8)} > ${textEllipses(targetInfo?.symbol || '', 8)}`\n\n          // 确保每个item都包含percent字段，并且总和为100%\n          const totalAmountOut = item.reduce((sum: number, i: any) => {\n            return sum + parseFloat(i.amountOut || '0')\n          }, 0)\n\n          // 先计算所有项目的原始百分比\n          const rawPercents: number[] = []\n          item.forEach((listItem: any) => {\n            const amountOut = parseFloat(listItem.amountOut || '0')\n            const rawPercent = totalAmountOut > 0 ? fixDown(d(amountOut).div(totalAmountOut).mul(100).toString(), 0) : '0'\n            rawPercents.push(Number(rawPercent) || 1)\n          })\n\n          // 计算总和并调整最后一个项目\n          // const totalRawPercent = rawPercents.reduce((sum, percent) => sum + percent, 0)\n          // if (rawPercents.length > 0) {\n          //   rawPercents[rawPercents.length - 1] += 100 - totalRawPercent\n          // }\n\n          const tempPercents = adjustTo100(rawPercents)\n\n          const processedList = item.map((listItem: any, index: number) => {\n            // 使用计算好的百分比，确保总和为100%\n            const percent = tempPercents[index]?.toString() || '0'\n            const fromInfo = tokenMap?.get(listItem?.from)\n\n            return {\n              ...listItem,\n              percent,\n              fromLogo: fromInfo?.logo_url,\n              targetLogo: targetInfo?.logo_url,\n              fromSymbol: fromInfo?.symbol,\n              targetSymbol: targetInfo?.symbol,\n              displayFee: getPercentage(formatFeeRate(listItem?.feeRate, 4))\n            }\n          })\n\n          return {\n            list: processedList.sort((a: any, b: any) => {\n              return Number(b?.percent) - Number(a?.percent)\n            }),\n            title\n          }\n        })\n      }\n    })\n  }, [nodes, tokenMap, resultColumes])\n\n  return (\n    <Box position=\"relative\" w=\"878px\" h={panelHeight ? `${panelHeight}px` : '531px'} ref={containerRef}>\n      <SvgEdges edges={edges} nodes={nodes} config={defaultConfig} />\n      <DrawBlock data={displayNodes} isWidget={isWidget} />\n    </Box>\n  )\n}\n\n// 检查线段是否与矩形相交\nfunction checkLineRectIntersection(\n  lineX1: number,\n  lineY1: number,\n  lineX2: number,\n  lineY2: number,\n  rectLeft: number,\n  rectTop: number,\n  rectWidth: number,\n  rectHeight: number\n): boolean {\n  const rectRight = rectLeft + rectWidth\n  const rectBottom = rectTop + rectHeight\n\n  // 检查线段是否与矩形相交\n  // 使用AABB（轴对齐包围盒）检测\n  const lineLeft = Math.min(lineX1, lineX2)\n  const lineRight = Math.max(lineX1, lineX2)\n  const lineTop = Math.min(lineY1, lineY2)\n  const lineBottom = Math.max(lineY1, lineY2)\n\n  // 如果线段完全在矩形外部，则不相交\n  if (lineRight < rectLeft || lineLeft > rectRight || lineBottom < rectTop || lineTop > rectBottom) {\n    return false\n  }\n\n  // 如果线段完全在矩形内部，则相交\n  if (lineLeft >= rectLeft && lineRight <= rectRight && lineTop >= rectTop && lineBottom <= rectBottom) {\n    return true\n  }\n\n  // 对于水平线，使用简单的边界检测\n  if (Math.abs(lineY1 - lineY2) < 0.001) {\n    // 水平线\n    if (lineY1 >= rectTop && lineY1 <= rectBottom) {\n      if (lineRight >= rectLeft && lineLeft <= rectRight) {\n        return true\n      }\n    }\n    return false\n  }\n\n  // 对于垂直线，使用简单的边界检测\n  if (Math.abs(lineX1 - lineX2) < 0.001) {\n    // 垂直线\n    if (lineX1 >= rectLeft && lineX1 <= rectRight) {\n      if (lineBottom >= rectTop && lineTop <= rectBottom) {\n        return true\n      }\n    }\n    return false\n  }\n\n  // 对于斜线，使用参数化方法检测\n  // 检查线段是否与矩形的四条边相交\n  const edges = [\n    // 上边\n    { x1: rectLeft, y1: rectTop, x2: rectRight, y2: rectTop },\n    // 下边\n    { x1: rectLeft, y1: rectBottom, x2: rectRight, y2: rectBottom },\n    // 左边\n    { x1: rectLeft, y1: rectTop, x2: rectLeft, y2: rectBottom },\n    // 右边\n    { x1: rectRight, y1: rectTop, x2: rectRight, y2: rectBottom }\n  ]\n\n  for (const edge of edges) {\n    if (linesIntersect(lineX1, lineY1, lineX2, lineY2, edge.x1, edge.y1, edge.x2, edge.y2)) {\n      return true\n    }\n  }\n\n  return false\n}\n\n// 辅助函数：检查两条线段是否相交\nfunction linesIntersect(x1: number, y1: number, x2: number, y2: number, x3: number, y3: number, x4: number, y4: number): boolean {\n  const denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4)\n  if (Math.abs(denom) < 0.001) return false // 使用更小的阈值\n\n  const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom\n  const u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / denom\n\n  return t >= 0 && t <= 1 && u >= 0 && u <= 1\n}\n\nfunction generateSmartPathWithNodeConnection(\n  fromX: number,\n  fromY: number,\n  toX: number,\n  toY: number,\n  toBlockHeight: number,\n  targetNodeWidth: number = 176,\n  isStart: boolean,\n  edge: any,\n  allNodes: any[] = [],\n  allEdges: any[] = [],\n  config: any = {}\n): string {\n  // 定义配置参数\n  const searchStep = config.searchStep || 5\n  const nodePadding = config.nodePadding || 10\n  const maxSearchDistance = config.maxSearchDistance || 50\n  const arrowOffset = config.arrowOffset || 5\n\n  // 检查线段是否与节点相交\n  const checkLineIntersection = (x1: number, y1: number, x2: number, y2: number): boolean => {\n    for (const node of allNodes) {\n      if (edge.from === node.id || edge.to === node.id) {\n        continue\n      }\n      if (checkLineRectIntersection(x1, y1, x2, y2, node.left, node.top, node.width, node.height)) {\n        return true\n      }\n    }\n    return false\n  }\n\n  // 检查从源节点到目标节点的水平连接是否可行\n  const checkHorizontalConnection = (sourceY: number): boolean => {\n    // 检查水平线是否与其他节点相交\n    if (checkLineIntersection(fromX, sourceY, toX - arrowOffset, sourceY)) {\n      return false\n    }\n\n    // 检查源节点和目标节点的位置关系\n    const sourceTop = sourceNode.top\n    const sourceBottom = sourceNode.top + sourceNode.height\n    const targetTop = targetNode.top\n    const targetBottom = targetNode.top + targetNode.height\n\n    // 如果源节点和目标节点有重叠的Y范围，检查连接点是否在重叠范围内\n    const overlapTop = Math.max(sourceTop, targetTop)\n    const overlapBottom = Math.min(sourceBottom, targetBottom)\n\n    if (overlapTop < overlapBottom) {\n      // 有重叠范围，检查连接点是否在重叠范围内\n      return sourceY >= overlapTop + nodePadding && sourceY <= overlapBottom - nodePadding\n    } else {\n      // 没有重叠范围，不能水平连接\n      return false\n    }\n  }\n\n  // 获取源节点和目标节点\n  const sourceNode = allNodes.find(node => node.id === edge.from)\n  const targetNode = allNodes.find(node => node.id === edge.to)\n\n  if (!sourceNode || !targetNode) {\n    return `M${fromX},${fromY} L${toX},${fromY == toY ? toY : fromY}`\n  }\n\n  // 1. 如果是起始线，连接到目标节点中心位置\n  if (isStart) {\n    const targetCenterY = targetNode.top + targetNode.height / 2\n    if (checkHorizontalConnection(targetCenterY)) {\n      return `M${fromX},${fromY} L${toX - arrowOffset},${targetCenterY}`\n    }\n\n    return `M${fromX},${fromY} L${toX - arrowOffset},${fromY}`\n  }\n\n  // 2. 检查源节点和目标节点的连接线数量\n  const sourceOutgoingEdges = allEdges.filter((e: any) => e.from === edge.from)\n  const targetIncomingEdges = allEdges.filter((e: any) => e.to === edge.to)\n\n  // 3. 如果源节点只有一条线出发，优先从高度中间位置连接\n  if (sourceOutgoingEdges.length === 1) {\n    const sourceCenterY = sourceNode.top + sourceNode.height / 2\n    if (checkHorizontalConnection(sourceCenterY)) {\n      return `M${fromX},${sourceCenterY} L${toX - arrowOffset},${sourceCenterY}`\n    }\n  }\n\n  // 4. 检查是否有直接水平连接的可能\n  const sourceTop = sourceNode.top\n  const sourceBottom = sourceNode.top + sourceNode.height\n  const targetTop = targetNode.top\n  const targetBottom = targetNode.top + targetNode.height\n\n  // 寻找重叠的Y范围\n  const overlapTop = Math.max(sourceTop, targetTop)\n  const overlapBottom = Math.min(sourceBottom, targetBottom)\n\n  if (overlapTop < overlapBottom) {\n    // 有重叠范围，在重叠范围内寻找连接点\n    for (let y = overlapTop + nodePadding; y <= overlapBottom - nodePadding; y += searchStep) {\n      if (checkHorizontalConnection(y)) {\n        // return `M${fromX},${y} L${toX - arrowOffset},${y}`\n        return `M${fromX},${y} L${toX - arrowOffset},${y}`\n      }\n    }\n  }\n\n  // 5. 如果没有直接连接的可能，检查是否可以向下/向上再横向连接\n  const sourceCenterY = sourceNode.top + sourceNode.height / 2\n  const targetCenterX = targetNode.left + targetNode.width / 2\n  const targetBottomY = targetNode.top + targetNode.height\n\n  if (sourceBottom - 10 < targetTop) {\n    // 源节点在目标节点上方，尝试向下再横向\n    const sourceCenterX = sourceNode.left + sourceNode.width / 2\n    const sourceCenterY = sourceNode.top + sourceNode.height\n    const downY = targetNode.top + targetNode.height / 2\n\n    // 检查向下路径是否无障碍\n    if (!checkLineIntersection(sourceCenterX, sourceBottom, sourceCenterX, downY)) {\n      // 检查横向路径是否无障碍\n      if (!checkLineIntersection(sourceCenterX, downY, toX - arrowOffset, downY)) {\n        return `M${sourceCenterX},${sourceCenterY} L${sourceCenterX},${sourceBottom} L${sourceCenterX},${downY} L${toX - arrowOffset},${downY}`\n      }\n    }\n\n    // 如果向下再横向不行，使用原来的L型路径\n\n    return `M${fromX},${sourceCenterY} L${targetCenterX},${sourceCenterY} L${targetCenterX},${targetBottomY}`\n  } else if (sourceTop + 10 >= targetBottom) {\n    // 源节点在目标节点下方，尝试向上再横向\n    // const sourceCenterX = sourceNode.left + sourceNode.width\n    // const upY = sourceTop - nodePadding\n\n    // 检查向上路径是否无障碍\n    // if (!checkLineIntersection(sourceCenterX, sourceTop, sourceCenterX, upY)) {\n    //   // 检查横向路径是否无障碍\n    //   if (!checkLineIntersection(sourceCenterX, upY, toX - arrowOffset, upY)) {\n    //     return `M${fromX},${sourceCenterY} L${sourceCenterX},${sourceTop} L${sourceCenterX},${upY} L${toX - arrowOffset},${upY}`\n    //   }\n    // }\n\n    // console.log('先向右再向上###sourceNode: ', sourceNode)\n    // console.log('先向右再向上###targetNode: ', targetNode)\n\n    // 如果向上再横向不行，使用原来的L型路径\n    return `M${fromX},${sourceCenterY} L${targetCenterX},${sourceCenterY} L${targetCenterX},${targetBottomY}`\n  }\n\n  // 6. 最后的备选方案：简单的L型路径\n  // const midX = fromX + 50\n  // return `M${fromX},${sourceCenterY} L${midX},${sourceCenterY} L${midX},${targetBottomY}`\n  return `M${fromX},${sourceCenterY} L${toX},${sourceCenterY}`\n}\n\nfunction SvgEdges({ edges, nodes, config }: { edges: any[]; nodes: any[]; config: any }) {\n  const svgRef = useRef<SVGSVGElement>(null)\n\n  return (\n    <svg\n      ref={svgRef}\n      style={{\n        position: 'absolute',\n        left: 0,\n        top: 0,\n        pointerEvents: 'none',\n        zIndex: 1,\n        width: '100%',\n        height: '100%'\n      }}\n    >\n      <defs>\n        <linearGradient id=\"arrowGradient\" x1=\"0%\" y1=\"0%\" x2=\"100%\" y2=\"0%\">\n          <stop offset=\"0%\" stopColor=\"rgba(0, 255, 165, 1)\" />\n          <stop offset=\"100%\" stopColor=\"rgba(0, 183, 255, 1)\" />\n        </linearGradient>\n        <marker id=\"arrowhead\" markerWidth=\"5\" markerHeight=\"9\" refX=\"4\" refY=\"4\" orient=\"auto\">\n          <path d=\"M1 1 L4 3.5 L1 6\" fill=\"none\" stroke=\"url(#arrowGradient)\" strokeWidth=\"1\" strokeLinecap=\"round\" strokeLinejoin=\"round\" />\n        </marker>\n      </defs>\n\n      {/* 额外的圆圈和连接线 */}\n      {(() => {\n        // 找到第一列最后一个连接线段的开始点（Y坐标最大的初始边）\n        const firstColumnEdges = edges?.filter(edge => edge.isStart) || []\n        console.log('🚀 ~ firstColumnEdges:', firstColumnEdges)\n        const lastFirstColumnEdge = firstColumnEdges.reduce((maxEdge, currentEdge) => {\n          // 找到Y坐标最大的初始边\n          return currentEdge.fromY > maxEdge.fromY ? currentEdge : maxEdge\n        }, firstColumnEdges[0])\n        console.log('🚀 ~ lastFirstColumnEdge:', lastFirstColumnEdge)\n\n        // 找到最后一列最后一个线段的结束点（从初始出发且Y坐标最大的）\n        const lastColumnEdges = edges?.filter(edge => edge.isFinal) || []\n        const lastThirdColumnEdge = lastColumnEdges.reduce((maxEdge, currentEdge) => {\n          // 找到Y坐标最大的边\n          return currentEdge.toY > maxEdge.toY ? currentEdge : maxEdge\n        }, lastColumnEdges[0])\n        console.log('🚀 ~ lastThirdColumnEdge:', lastThirdColumnEdge)\n\n        if (lastFirstColumnEdge && lastThirdColumnEdge) {\n          const leftCircleX = 13\n          const leftCircleY = 4\n          const rightCircleX = 878 - 13 // routerComWidth - 28\n          const rightCircleY = 4\n\n          // 左侧连接线：从左侧圆圈中心向下连接到第一列最后一个连接线段的开始点\n          const leftConnectionPath = `M ${leftCircleX} ${leftCircleY + 4} Q ${leftCircleX} ${lastFirstColumnEdge.fromY - 10} ${lastFirstColumnEdge.fromX} ${lastFirstColumnEdge.fromY}`\n\n          // 右侧连接线：从右侧圆圈中心向下连接到最后一列最后一个线段的结束点\n          const rightConnectionPath = `M ${rightCircleX} ${rightCircleY} L ${rightCircleX} ${lastThirdColumnEdge.toY} L ${lastThirdColumnEdge.toX} ${lastThirdColumnEdge.toY}`\n\n          return (\n            <g>\n              {/* 左侧连接线 */}\n              <path d={leftConnectionPath} stroke=\"#2D2D2D\" strokeWidth={pathStrokeWidth} fill=\"none\" />\n\n              {/* 右侧连接线 */}\n              <path d={rightConnectionPath} stroke=\"#2D2D2D\" strokeWidth={pathStrokeWidth} fill=\"none\" />\n\n              {/* 左侧圆圈 */}\n              <circle cx={leftCircleX} cy={leftCircleY} r=\"4\" fill=\"#75C8FF\" />\n\n              {/* 右侧圆圈 */}\n              <circle cx={rightCircleX} cy={rightCircleY} r=\"4\" fill=\"#75C8FF\" />\n            </g>\n          )\n        }\n        return null\n      })()}\n\n      {/* 第一层：fromCoinType直接到targetCoinType的跨列连接（画在最上面） */}\n      {edges\n        ?.filter((edge: any) => edge.isCrossColumnConnection && edge.isStart)\n        ?.map((edge, idx) => {\n          let path: string\n          let labelX: number\n          let labelY: number\n\n          // 检查是否有segments字段（多段线条）\n          if (edge.segments && edge.segments.length > 0) {\n            // 使用segments生成多段路径\n            path = edge.segments\n              .map((segment: any, segmentIdx: number) => {\n                if (segmentIdx === 0) {\n                  return `M${segment.x1},${segment.y1} L${segment.x2},${segment.y2}`\n                } else {\n                  return `L${segment.x2},${segment.y2}`\n                }\n              })\n              .join(' ')\n\n            // 对于多段线条，根据第一段方向确定标签位置\n            const firstSegment = edge.segments[0]\n\n            // 判断第一段的方向\n            const deltaX = firstSegment.x2 - firstSegment.x1\n            const deltaY = firstSegment.y2 - firstSegment.y1\n\n            if (Math.abs(deltaX) > Math.abs(deltaY)) {\n              // 第一段主要是向右或向左\n              labelY = (firstSegment.y1 + firstSegment.y2) / 2 // 线段上下居中\n              labelX = firstSegment.x1 + 30 // fromX + 30\n            } else if (deltaY < 0) {\n              // 第一段向上\n              labelY = firstSegment.y1 - 16\n              labelX = (firstSegment.x1 + firstSegment.x2) / 2 // 线段左右居中\n            } else {\n              // 第一段向下\n              labelY = firstSegment.y1 + 30 // fromY + 30\n              labelX = (firstSegment.x1 + firstSegment.x2) / 2 // 线段左右居中\n            }\n          } else {\n            // 使用原来的逻辑生成单段路径\n            path = generateSmartPathWithNodeConnection(\n              edge.fromX,\n              edge.fromY,\n              edge.toX,\n              edge.toY,\n              edge.toBlockHeight,\n              config.nodeWidth,\n              !!edge.isStart,\n              edge,\n              nodes,\n              edges,\n              config\n            )\n\n            // 计算标签位置\n            // 从生成的路径中解析出实际的出发位置和路径类型\n            const pathParts = path.split(' ')\n            let actualStartX = edge.fromX\n            let actualStartY = edge.fromY\n            let isDownThenHorizontal = false\n\n            // 解析路径的第一个点作为实际出发位置\n            if (pathParts.length > 0 && pathParts[0].startsWith('M')) {\n              const startCoords = pathParts[0].substring(1).split(',')\n              if (startCoords.length === 2) {\n                actualStartX = parseFloat(startCoords[0])\n                actualStartY = parseFloat(startCoords[1])\n              }\n            }\n\n            // 检查是否是先向下然后横向的路径\n            if (pathParts.length >= 3) {\n              const firstSegment = pathParts[1] // 第一个L命令\n              const secondSegment = pathParts[2] // 第二个L命令\n\n              if (firstSegment && secondSegment) {\n                const firstCoords = firstSegment.substring(1).split(',')\n                const secondCoords = secondSegment.substring(1).split(',')\n\n                if (firstCoords.length === 2 && secondCoords.length === 2) {\n                  const firstY = parseFloat(firstCoords[1])\n                  const secondY = parseFloat(secondCoords[1])\n\n                  // 如果第一段的Y小于第二段的Y，说明是先向下再横向\n                  if (firstY < secondY) {\n                    isDownThenHorizontal = true\n                  }\n                }\n              }\n            }\n\n            // 根据路径类型确定标签位置\n            if (isDownThenHorizontal) {\n              // 先向下然后横向：X是标签宽度居中和线对齐，Y大于当前出发Y+5\n              const textContent = edge.fromPercent ? `${edge.fromPercent}%` : ''\n              const textWidth = textContent.length * 6\n              const backgroundWidth = Math.max(42, textWidth + 10)\n              labelX = actualStartX // 标签中轴线与向下线对齐\n              labelY = actualStartY + 12 // Y再向下5（从原来的+5改为+10）\n            } else {\n              // 其他情况：标签应该展示在实际出发位置+30的x和当前y的位置（上下居中）\n              labelX = actualStartX + 30\n              labelY = actualStartY\n            }\n          }\n\n          // 计算背景矩形的尺寸\n          const textContent = edge.fromPercent ? `${edge.fromPercent}%` : ''\n          const textWidth = textContent.length * 6 // 更精确的文字宽度估算\n          const backgroundWidth = Math.max(42, textWidth + 10) // 最小宽度42，左右各10边距\n          const backgroundHeight = 16\n          const backgroundX = labelX - backgroundWidth / 2\n          const backgroundY = labelY - backgroundHeight / 2\n\n          return (\n            <g key={`cross-${idx}`}>\n              <path\n                d={path}\n                stroke=\"#2D2D2D\"\n                strokeWidth={pathStrokeWidth}\n                fill=\"none\"\n                markerEnd=\"url(#arrowhead)\"\n                strokeLinecap=\"square\"\n                strokeLinejoin=\"miter\"\n              />\n              {/* 背景矩形 */}\n              <rect x={backgroundX} y={backgroundY} width={backgroundWidth} height={backgroundHeight} rx=\"4\" ry=\"4\" fill=\"#192128\" />\n              {/* 百分比文字 */}\n              <text\n                x={labelX} // 使用labelX作为中心点，因为背景矩形就是以labelX为中心的\n                y={backgroundY + backgroundHeight / 2 + 0.5} // 文字在背景矩形的垂直中心位置\n                fontSize=\"10\"\n                fill=\"#00B7FF\"\n                textAnchor=\"middle\"\n                dominantBaseline=\"middle\"\n                pointerEvents=\"auto\"\n              >\n                {textContent}\n              </text>\n            </g>\n          )\n        })}\n\n      {/* 第二层：fromCoinType直接到第二列的连接 */}\n      {edges\n        ?.filter((edge: any) => edge.renderOnTop)\n        ?.map((edge, idx) => {\n          let path: string\n          let labelX: number\n          let labelY: number\n\n          // 检查是否有segments字段（多段线条）\n          if (edge.segments && edge.segments.length > 0) {\n            // 使用segments生成多段路径\n            path = edge.segments\n              .map((segment: any, segmentIdx: number) => {\n                if (segmentIdx === 0) {\n                  return `M${segment.x1},${segment.y1} L${segment.x2},${segment.y2}`\n                } else {\n                  return `L${segment.x2},${segment.y2}`\n                }\n              })\n              .join(' ')\n\n            // 对于多段线条，根据第一段方向确定标签位置\n            const firstSegment = edge.segments[0]\n\n            // 判断第一段的方向\n            const deltaX = firstSegment.x2 - firstSegment.x1\n            const deltaY = firstSegment.y2 - firstSegment.y1\n\n            if (Math.abs(deltaX) > Math.abs(deltaY)) {\n              // 第一段主要是向右或向左\n              labelY = (firstSegment.y1 + firstSegment.y2) / 2 // 线段上下居中\n              labelX = firstSegment.x1 + 30 // fromX + 30\n            } else if (deltaY < 0) {\n              // 第一段向上\n              labelY = firstSegment.y1 - 16\n              labelX = (firstSegment.x1 + firstSegment.x2) / 2 // 线段左右居中\n            } else {\n              // 第一段向下\n              labelY = firstSegment.y1 + 30 // fromY + 30\n              labelX = (firstSegment.x1 + firstSegment.x2) / 2 // 线段左右居中\n            }\n          } else {\n            // 使用原来的逻辑生成单段路径\n            path = generateSmartPathWithNodeConnection(\n              edge.fromX,\n              edge.fromY,\n              edge.toX,\n              edge.toY,\n              edge.toBlockHeight,\n              config.nodeWidth,\n              !!edge.isStart,\n              edge,\n              nodes,\n              edges,\n              config\n            )\n\n            // 计算标签位置\n            labelX = (edge.fromX + edge.toX) / 2\n            labelY = (edge.fromY + edge.toY) / 2\n          }\n\n          // 计算背景矩形的尺寸\n          const textContent = edge.fromPercent ? `${edge.fromPercent}%` : ''\n          const textWidth = textContent.length * 6\n          const backgroundWidth = Math.max(42, textWidth + 10)\n          const backgroundHeight = 16\n          const backgroundX = labelX - backgroundWidth / 2\n          const backgroundY = labelY - backgroundHeight / 2\n\n          return (\n            <g key={`cross-other-${idx}`}>\n              <path\n                d={path}\n                stroke=\"#2D2D2D\"\n                strokeWidth={pathStrokeWidth}\n                fill=\"none\"\n                markerEnd=\"url(#arrowhead)\"\n                strokeLinecap=\"square\"\n                strokeLinejoin=\"miter\"\n              />\n              {/* 背景矩形 */}\n              <rect x={backgroundX} y={backgroundY} width={backgroundWidth} height={backgroundHeight} rx=\"4\" ry=\"4\" fill=\"#192128\" />\n              {/* 百分比文字 */}\n              <text\n                x={labelX}\n                y={backgroundY + backgroundHeight / 2 + 0.5}\n                fontSize=\"10\"\n                fill=\"#00B7FF\"\n                textAnchor=\"middle\"\n                dominantBaseline=\"middle\"\n                pointerEvents=\"auto\"\n              >\n                {textContent}\n              </text>\n            </g>\n          )\n        })}\n\n      {/* 第三层：其他跨列连接（但不包括fromCoinType直接到第二列和targetCoinType的） */}\n      {edges\n        ?.filter((edge: any) => edge.isCrossColumnConnection && !edge.isStart && !edge.renderOnTop)\n        ?.map((edge, idx) => {\n          let path: string\n          let labelX: number\n          let labelY: number\n\n          // 检查是否有segments字段（多段线条）\n          if (edge.segments && edge.segments.length > 0) {\n            // 使用segments生成多段路径\n            path = edge.segments\n              .map((segment: any, segmentIdx: number) => {\n                if (segmentIdx === 0) {\n                  return `M${segment.x1},${segment.y1} L${segment.x2},${segment.y2}`\n                } else {\n                  return `L${segment.x2},${segment.y2}`\n                }\n              })\n              .join(' ')\n\n            // 对于多段线条，根据第一段方向确定标签位置\n            const firstSegment = edge.segments[0]\n\n            // 判断第一段的方向\n            const deltaX = firstSegment.x2 - firstSegment.x1\n            const deltaY = firstSegment.y2 - firstSegment.y1\n\n            if (Math.abs(deltaX) > Math.abs(deltaY)) {\n              // 第一段主要是向右或向左\n              labelY = (firstSegment.y1 + firstSegment.y2) / 2 // 线段上下居中\n              labelX = firstSegment.x1 + 30 // fromX + 30\n            } else if (deltaY < 0) {\n              // 第一段向上\n              labelY = firstSegment.y1 - 16\n              labelX = (firstSegment.x1 + firstSegment.x2) / 2 // 线段左右居中\n            } else {\n              // 第一段向下\n              labelY = firstSegment.y1 + 30 // fromY + 30\n              labelX = (firstSegment.x1 + firstSegment.x2) / 2 // 线段左右居中\n            }\n          } else {\n            // 使用原来的逻辑生成单段路径\n            path = generateSmartPathWithNodeConnection(\n              edge.fromX,\n              edge.fromY,\n              edge.toX,\n              edge.toY,\n              edge.toBlockHeight,\n              config.nodeWidth,\n              !!edge.isStart,\n              edge,\n              nodes,\n              edges,\n              config\n            )\n\n            // 计算标签位置\n            labelX = (edge.fromX + edge.toX) / 2\n            labelY = (edge.fromY + edge.toY) / 2\n          }\n\n          // 计算背景矩形的尺寸\n          const textContent = edge.fromPercent ? `${edge.fromPercent}%` : ''\n          const textWidth = textContent.length * 6\n          const backgroundWidth = Math.max(42, textWidth + 10)\n          const backgroundHeight = 16\n          const backgroundX = labelX - backgroundWidth / 2\n          const backgroundY = labelY - backgroundHeight / 2\n\n          return (\n            <g key={`cross-other-${idx}`}>\n              <path\n                d={path}\n                stroke=\"#2D2D2D\"\n                strokeWidth={pathStrokeWidth}\n                fill=\"none\"\n                markerEnd=\"url(#arrowhead)\"\n                strokeLinecap=\"square\"\n                strokeLinejoin=\"miter\"\n              />\n              {/* 背景矩形 */}\n              <rect x={backgroundX} y={backgroundY} width={backgroundWidth} height={backgroundHeight} rx=\"4\" ry=\"4\" fill=\"#192128\" />\n              {/* 百分比文字 */}\n              <text\n                x={labelX}\n                y={backgroundY + backgroundHeight / 2 + 0.5}\n                fontSize=\"10\"\n                fill=\"#00B7FF\"\n                textAnchor=\"middle\"\n                dominantBaseline=\"middle\"\n                pointerEvents=\"auto\"\n              >\n                {textContent}\n              </text>\n            </g>\n          )\n        })}\n\n      {/* 第四层：所有其他连接（排除前面已经渲染的） */}\n      {edges\n        ?.filter((edge: any) => !edge.isCrossColumnConnection && !edge.renderOnTop)\n        ?.map((edge, idx) => {\n          let path: string\n          let labelX: number\n          let labelY: number\n\n          // 检查是否有segments字段（多段线条）\n          if (edge.segments && edge.segments.length > 0) {\n            console.log('🔍 第四层发现segments，数量:', edge.segments.length, 'edge:', edge)\n            // 使用segments生成多段路径\n            path = edge.segments\n              .map((segment: any, segmentIdx: number) => {\n                if (segmentIdx === 0) {\n                  return `M${segment.x1},${segment.y1} L${segment.x2},${segment.y2}`\n                } else {\n                  return `L${segment.x2},${segment.y2}`\n                }\n              })\n              .join(' ')\n\n            // 对于多段线条，根据第一段方向确定标签位置\n            const firstSegment = edge.segments[0]\n\n            // 判断第一段的方向\n            const deltaX = firstSegment.x2 - firstSegment.x1\n            const deltaY = firstSegment.y2 - firstSegment.y1\n\n            if (Math.abs(deltaX) > Math.abs(deltaY)) {\n              // 第一段主要是向右或向左\n              labelY = (firstSegment.y1 + firstSegment.y2) / 2 // 线段上下居中\n              labelX = firstSegment.x1 + 30 // fromX + 30\n            } else if (deltaY < 0) {\n              // 第一段向上\n              labelY = firstSegment.y1 - 16\n              labelX = (firstSegment.x1 + firstSegment.x2) / 2 // 线段左右居中\n            } else {\n              // 第一段向下\n              labelY = firstSegment.y1 + 30 // fromY + 30\n              labelX = (firstSegment.x1 + firstSegment.x2) / 2 // 线段左右居中\n            }\n          } else {\n            // 使用原来的逻辑生成单段路径\n            path = generateSmartPathWithNodeConnection(\n              edge.fromX,\n              edge.fromY,\n              edge.toX,\n              edge.toY,\n              edge.toBlockHeight,\n              config.nodeWidth,\n              !!edge.isStart,\n              edge,\n              nodes,\n              edges,\n              config\n            )\n\n            // 计算标签位置\n            // 从生成的路径中解析出实际的出发位置和路径类型\n            const pathParts = path.split(' ')\n            let actualStartX = edge.fromX\n            let actualStartY = edge.fromY\n            let isDownThenHorizontal = false\n\n            // 解析路径的第一个点作为实际出发位置\n            if (pathParts.length > 0 && pathParts[0].startsWith('M')) {\n              const startCoords = pathParts[0].substring(1).split(',')\n              if (startCoords.length === 2) {\n                actualStartX = parseFloat(startCoords[0])\n                actualStartY = parseFloat(startCoords[1])\n              }\n            }\n\n            // 检查是否是先向下然后横向的路径\n            if (pathParts.length >= 3) {\n              const firstSegment = pathParts[1] // 第一个L命令\n              const secondSegment = pathParts[2] // 第二个L命令\n\n              if (firstSegment && secondSegment) {\n                const firstCoords = firstSegment.substring(1).split(',')\n                const secondCoords = secondSegment.substring(1).split(',')\n\n                if (firstCoords.length === 2 && secondCoords.length === 2) {\n                  const firstY = parseFloat(firstCoords[1])\n                  const secondY = parseFloat(secondCoords[1])\n\n                  // 如果第一段的Y小于第二段的Y，说明是先向下再横向\n                  if (firstY < secondY) {\n                    isDownThenHorizontal = true\n                  }\n                }\n              }\n            }\n\n            // 根据路径类型确定标签位置\n            if (isDownThenHorizontal) {\n              // 先向下然后横向：X是标签宽度居中和线对齐，Y大于当前出发Y+5\n              const textContent = edge.fromPercent ? `${edge.fromPercent}%` : ''\n              const textWidth = textContent.length * 6\n              const backgroundWidth = Math.max(42, textWidth + 10)\n              labelX = actualStartX // 标签中轴线与向下线对齐\n              labelY = actualStartY + 12 // Y再向下5（从原来的+5改为+10）\n            } else {\n              // 其他情况：标签应该展示在实际出发位置+30的x和当前y的位置（上下居中）\n              labelX = actualStartX + 30\n              labelY = actualStartY\n            }\n          }\n\n          // 计算背景矩形的尺寸\n          const textContent = edge.fromPercent ? `${edge.fromPercent}%` : ''\n          const textWidth = textContent.length * 6 // 更精确的文字宽度估算\n          const backgroundWidth = Math.max(42, textWidth + 10) // 最小宽度42，左右各10边距\n          const backgroundHeight = 16\n          const backgroundX = labelX - backgroundWidth / 2\n          const backgroundY = labelY - backgroundHeight / 2\n\n          return (\n            <g key={`normal-${idx}`}>\n              <path\n                d={path}\n                stroke=\"#2D2D2D\"\n                strokeWidth={pathStrokeWidth}\n                fill=\"none\"\n                markerEnd=\"url(#arrowhead)\"\n                strokeLinecap=\"square\"\n                strokeLinejoin=\"miter\"\n              />\n              {/* 背景矩形 */}\n              <rect x={backgroundX} y={backgroundY} width={backgroundWidth} height={backgroundHeight} rx=\"4\" ry=\"4\" fill=\"#192128\" />\n              {/* 百分比文字 */}\n              <text\n                x={labelX} // 使用labelX作为中心点，因为背景矩形就是以labelX为中心的\n                y={backgroundY + backgroundHeight / 2 + 0.5} // 文字在背景矩形的垂直中心位置\n                fontSize=\"10\"\n                fill=\"#00B7FF\"\n                textAnchor=\"middle\"\n                dominantBaseline=\"middle\"\n                pointerEvents=\"auto\"\n              >\n                {textContent}\n              </text>\n            </g>\n          )\n        })}\n    </svg>\n  )\n}\n\nfunction DrawBlock({ data, isWidget }: { data: any; isWidget?: boolean }) {\n  return (\n    <Box w=\"100%\" position=\"relative\" h=\"100%\" zIndex={2}>\n      {data?.map((targetNode: any) => {\n        return <TargetBlock key={targetNode.target} data={targetNode} isWidget={isWidget} />\n      })}\n    </Box>\n  )\n}\n\nfunction TargetBlock({ data, isWidget }: { data: any; isWidget?: boolean }) {\n  return (\n    <VStack\n      w=\"176px\"\n      p=\"8px\"\n      gap=\"0px\"\n      bg={isWidget ? 'swap_bg_primary' : 'background'}\n      borderRadius=\"8px\"\n      border=\"1px solid\"\n      borderColor={isWidget ? '#242C33' : 'border'}\n      position=\"absolute\"\n      left={data?.left}\n      top={data?.top + 'px'}\n      data-node-id={data?.target}\n      key={data?.target}\n    >\n      <Box w=\"100%\">\n        <TokenToolTip data={data}>\n          <HStack w=\"100%\" h=\"24px\" justify=\"flex-start\">\n            <SingleCoinImage imageUrl={data?.targetImg} coinType={data?.originalTarget} showTagWidth=\"12px\" showTagHeight=\"12px\" w=\"24px\" h=\"24px\" />\n            <Text fontSize=\"14px\" color=\"text_caption\">\n              {textEllipses(data?.targetSymbol || '', 16)}\n            </Text>\n          </HStack>\n        </TokenToolTip>\n      </Box>\n\n      {data?.fromGroups?.map((item: any) => {\n        return <PathItem key={item.from} data={item} isWidget={isWidget} />\n      })}\n    </VStack>\n  )\n}\n\nfunction PathItem({ data, isWidget }: { data: any; isWidget?: boolean }) {\n  return (\n    <VStack p=\"12px 8px\" bg={isWidget ? '#1F2933' : '#1C1C1C'} borderRadius=\"8px\" w=\"100%\" gap=\"0px\" mt=\"8px\">\n      <Text h=\"16px\" fontSize=\"14px\" color=\"primary_gray\" w=\"100%\">\n        {data?.title}\n      </Text>\n      <VStack gap=\"0px\" w=\"100%\" align=\"flex-start\" mt=\"10px\">\n        {data?.list?.map((item: any) => {\n          return (\n            <PathToolTip key={item?.id} data={item}>\n              <HStack key={item.provider} h=\"22px\" w=\"100%\" gap=\"0px\" cursor=\"pointer\">\n                <SingleCoinImage imageUrl={AggregatorDexMap[item?.provider]?.logo} w=\"16px\" h=\"16px\" />\n                <Text fontSize=\"12px\" color=\"primary_gray\" ml=\"4px\">\n                  {AggregatorDexMap[item?.provider]?.name}\n                </Text>\n                <Text fontSize=\"12px\" color=\"primary_gray\" flex=\"1\" textAlign=\"right\">\n                  {item?.percent}%\n                </Text>\n              </HStack>\n            </PathToolTip>\n          )\n        })}\n      </VStack>\n    </VStack>\n  )\n}\n\nfunction PathToolTip({ children, data }: { children: any; data: any }) {\n  const { isApp } = useWindowWidth()\n  const { getExplorerUrl } = useExplorer()\n  return (\n    <Popover isLazy trigger={isApp ? 'click' : 'hover'} gutter={4}>\n      <PopoverTrigger>{children}</PopoverTrigger>\n      <Portal>\n        <PopoverContent w=\"unset\" minW=\"unset\">\n          <PopoverBody p=\"12px\">\n            <VStack w=\"190px\" gap=\"12px\" className=\"no-close-widget-flag\">\n              <HStack w=\"100%\" justify=\"space-between\" p=\"0\" gap=\"0px\">\n                <CoinPairImage\n                  coinAIconUrl={data?.fromLogo}\n                  coinBIconUrl={data?.targetLogo}\n                  variant=\"\"\n                  p=\"0px\"\n                  w=\"16px\"\n                  h=\"16px\"\n                  imageStyle={{ decoding: 'async' }}\n                  coinACoinType={data?.from}\n                  coinBCoinType={data?.target}\n                  showTagWidth=\"10px\"\n                  showTagHeight=\"10px\"\n                />\n                <Text fontSize=\"12px\" color=\"text_caption\" flex={1} textAlign=\"left\" ml=\"4px\">\n                  {textEllipses(data?.fromSymbol || '', 8)} - {textEllipses(data?.targetSymbol || '', 8)}\n                </Text>\n                {data?.feeRate && Number(data?.feeRate) > 0 && (\n                  <Center minW=\"50px\" h=\"16px\" border=\"1px solid\" borderColor=\"border\" borderRadius=\"12px\" p=\"0px 6px\">\n                    <Text fontSize=\"12px\" color=\"#76C8FF\" lineHeight=\"12px\" fontWeight=\"400\">\n                      {data.displayFee}\n                    </Text>\n                  </Center>\n                )}\n              </HStack>\n              {data?.id && (\n                <HStack w=\"100%\" justify=\"space-between\" h=\"20px\" p=\"0\">\n                  <HStack>\n                    {/* <Image src={pool_img} w=\"20px\" h=\"20px\" /> */}\n                    <Text fontSize=\"12px\" color=\"text_paragraph\">\n                      Pool\n                    </Text>\n                  </HStack>\n                  <AddressCopyLink\n                    address={data?.id as string}\n                    color=\"text_caption\"\n                    showLink={isApp ? true : false}\n                    onClickLink={() => {\n                      window.open(getExplorerUrl(data?.id, 'poolAddress'), '_blank')\n                    }}\n                  />\n                </HStack>\n              )}\n            </VStack>\n          </PopoverBody>\n        </PopoverContent>\n      </Portal>\n    </Popover>\n  )\n}\n\nfunction TokenToolTip({ data, children }: { data: any; children: any }) {\n  const { getExplorerUrl } = useExplorer()\n  return (\n    <CetusTooltip\n      placement=\"top\"\n      showTooltip={true}\n      tooltip={\n        <HStack w=\"100%\" justify=\"flex-start\">\n          <SingleCoinImage\n            imageUrl={data?.targetImg}\n            w=\"20px\"\n            h=\"20px\"\n            minH=\"20px\"\n            minW=\"20px\"\n            showTag={true}\n            showTagWidth=\"10px\"\n            showTagHeight=\"10px\"\n            coinType={data?.originalTarget}\n          />\n          <Text color=\"text_caption\"> {textEllipses(data?.targetSymbol, 10)}</Text>\n          <AddressCopyLink address={data?.originalTarget} onClickLink={() => window.open(getExplorerUrl(data?.originalTarget, 'coin'))} />\n        </HStack>\n      }\n    >\n      <Box w=\"100%\">{children}</Box>\n    </CetusTooltip>\n  )\n}\n","import V3Router from '@/components/swap/V3Router'\nimport { useGetToken } from '@cetus/hooks/src/useToken'\nimport useWindowWidth from '@cetus/hooks/src/useWindowWidth'\nimport { Token } from '@cetus/types'\nimport { SingleCoinImage } from '@cetus/ui-kit'\nimport { addComma, bnToAmount } from '@cetus/utils'\nimport { fixCoinType } from '@cetusprotocol/common-sdk'\nimport { Box, HStack, Modal, ModalBody, ModalCloseButton, ModalContent, ModalHeader, ModalOverlay, Text } from '@chakra-ui/react'\nimport { useCallback, useEffect, useMemo, useRef, useState } from 'react'\nimport OverView from './OverView'\n\ninterface RoutesModalProps {\n  isOpen: boolean\n  onClose: () => void\n  data?: any\n  mergeSwapData?: {\n    allRoutes: any\n    currentIndex?: number\n  }\n  fromCoin?: Token\n  toCoin?: Token\n  fromAmount?: string\n  toAmount?: string\n  allProviders?: string[]\n}\n\nconst RoutesModal = ({ isOpen, onClose, data, fromCoin, toCoin, fromAmount, toAmount, allProviders, mergeSwapData }: RoutesModalProps) => {\n  const { isApp } = useWindowWidth()\n  const { getTokenListInfo } = useGetToken()\n\n  const allRoutes = mergeSwapData?.allRoutes\n  const currentIndex = mergeSwapData?.currentIndex ?? 0\n  const isMergeSwap = Boolean(allRoutes?.length)\n\n  const [currentMergeSwapIndex, setCurrentMergeSwapIndex] = useState(currentIndex)\n  const [mergeFromCoinList, setMergeFromCoinList] = useState<any[]>([])\n\n  const stableAllRoutes = useMemo(() => allRoutes, [allRoutes])\n\n  useEffect(() => {\n    if (allRoutes?.length) {\n      if (currentIndex >= allRoutes?.length) {\n        setCurrentMergeSwapIndex(0)\n      } else {\n        setCurrentMergeSwapIndex(currentIndex)\n      }\n    }\n  }, [currentIndex, allRoutes?.length])\n\n  const handleChangeMergeSwapIndex = (coinType: string) => {\n    const index = allRoutes?.findIndex((item: any) => fixCoinType(item.paths[0].from) === fixCoinType(coinType)) ?? -1\n    if (index >= 0) {\n      setCurrentMergeSwapIndex(index)\n    }\n  }\n\n  const v3RouterData = useMemo(() => {\n    if (isMergeSwap && stableAllRoutes?.[currentMergeSwapIndex]) {\n      return { routerData: stableAllRoutes[currentMergeSwapIndex] }\n    }\n    return data\n  }, [isMergeSwap, stableAllRoutes, currentMergeSwapIndex, data])\n\n  const currentAllProviders = useMemo(() => {\n    // if (isMergeSwap && stableAllRoutes?.[currentMergeSwapIndex]) {\n    //   const providers = stableAllRoutes[currentMergeSwapIndex]?.paths.map((item: any) => item.provider) as string[]\n    //   return [...new Set(providers)] // 去重\n    // }\n    return allProviders || []\n  }, [isMergeSwap, stableAllRoutes, currentMergeSwapIndex, allProviders])\n\n  const getTokenListInfoRef = useRef(getTokenListInfo)\n  getTokenListInfoRef.current = getTokenListInfo\n\n  const [mergeSwapToCoin, setMergeSwapToCoin] = useState(toCoin)\n\n  useEffect(() => {\n    if (!isMergeSwap || !stableAllRoutes?.length) return\n\n    const fetchMergeFromCoinList = async () => {\n      try {\n        const coinTypeList = stableAllRoutes.map((item: any) => item.paths[0].from)\n        const toCoinType = stableAllRoutes[0]?.paths[stableAllRoutes[0]?.paths.length - 1]?.target\n\n        if (!toCoinType) return\n\n        const res = await getTokenListInfoRef.current([...coinTypeList, toCoinType])\n        if (!res) return\n\n        const toCoin = res.get(toCoinType)\n\n        setMergeSwapToCoin(toCoin)\n\n        const coinListData = stableAllRoutes.map((item: any) => {\n          const fromCoinType = item.paths[0].from\n          const fromCoin = res.get(fromCoinType)\n\n          return {\n            ...fromCoin,\n            amountIn: bnToAmount(item.amountIn?.toString(), fromCoin?.decimals || 0),\n            amountOut: bnToAmount(item.amountOut?.toString(), toCoin?.decimals || 0)\n          }\n        })\n\n        setMergeFromCoinList(coinListData)\n      } catch (error) {\n        console.error('Failed to get merge from coin list:', error)\n      }\n    }\n\n    fetchMergeFromCoinList()\n  }, [isMergeSwap, stableAllRoutes])\n\n  const fromCoinType = useMemo(() => {\n    if (isMergeSwap && mergeFromCoinList.length > 0 && currentMergeSwapIndex >= 0) {\n      return mergeFromCoinList[currentMergeSwapIndex]?.coin_type\n    }\n    return fromCoin?.coin_type\n  }, [isMergeSwap, mergeFromCoinList, currentMergeSwapIndex, fromCoin?.coin_type])\n\n  const currentToCoin = useMemo(() => {\n    if (isMergeSwap && mergeSwapToCoin?.coin_type) {\n      return mergeSwapToCoin\n    }\n    return toCoin\n  }, [isMergeSwap, mergeSwapToCoin?.coin_type, toCoin?.coin_type])\n\n  const currentToAmount = useMemo(() => {\n    if (isMergeSwap && mergeFromCoinList.length > 0 && currentMergeSwapIndex >= 0) {\n      return mergeFromCoinList[currentMergeSwapIndex]?.amountOut\n    }\n    return toAmount\n  }, [isMergeSwap, mergeFromCoinList, currentMergeSwapIndex, toAmount])\n\n  return (\n    <Modal autoFocus={false} returnFocusOnClose={false} isOpen={isOpen} onClose={onClose} isCentered>\n      <ModalOverlay />\n      <ModalContent maxW=\"1200px\" w={isApp ? 'calc(100vw - 32px)' : '910px'} bg=\"background\">\n        <ModalHeader mr=\"-10px\">\n          <HStack w=\"100%\" gap=\"24px\" justify=\"space-between\" align=\"center\">\n            <Text fontSize=\"16px\" fontWeight=\"500\" color=\"text_caption\">\n              Route\n            </Text>\n            <HStack gap=\"0\" align=\"center\">\n              <OverView allProviders={currentAllProviders} />\n              <ModalCloseButton mt=\"0\" position=\"static\" />\n            </HStack>\n          </HStack>\n        </ModalHeader>\n\n        <ModalBody p={{ base: '8px 16px', lg: '16px' }}>\n          <Box w=\"100%\" overflowX={isApp ? 'auto' : 'hidden'}>\n            <Box w=\"876px\">\n              <HStack w=\"100%\" h=\"100%\" justify=\"space-between\" align=\"center\" mb=\"16px\">\n                {isMergeSwap ? (\n                  <FromCoinTabs list={mergeFromCoinList} defaultIndex={currentMergeSwapIndex} onChange={handleChangeMergeSwapIndex} />\n                ) : (\n                  <HStack>\n                    <SingleCoinImage imageUrl={fromCoin?.logo_url} w=\"24px\" h=\"24px\" />\n                    <Text fontSize=\"14px\" fontWeight=\"500\" color=\"text_caption\">\n                      {addComma(fromAmount || '0')}\n                    </Text>\n                    <Text fontSize=\"14px\" fontWeight=\"500\" color=\"primary_gray\">\n                      {fromCoin?.symbol}\n                    </Text>\n                  </HStack>\n                )}\n                <HStack>\n                  <Text fontSize=\"14px\" fontWeight=\"500\" color=\"text_caption\">\n                    {addComma(currentToAmount || '0')}\n                  </Text>\n                  <Text fontSize=\"14px\" fontWeight=\"500\" color=\"primary_gray\">\n                    {currentToCoin?.symbol}\n                  </Text>\n                  <SingleCoinImage imageUrl={toCoin?.logo_url} w=\"24px\" h=\"24px\" />\n                </HStack>\n              </HStack>\n              {fromCoinType && currentToCoin?.coin_type && (\n                <V3Router data={v3RouterData} originFromCoinType={fromCoinType} originToCoinType={currentToCoin?.coin_type} />\n              )}\n            </Box>\n          </Box>\n        </ModalBody>\n      </ModalContent>\n    </Modal>\n  )\n}\n\nfunction FromCoinTabs({ list, defaultIndex, onChange }: { list: any; defaultIndex: number; onChange: (coinType: string) => void }) {\n  const currentCoinType = list[defaultIndex]?.coin_type\n\n  const handleChangeCoinType = useCallback(\n    (coinType: string) => {\n      onChange(coinType)\n    },\n    [onChange]\n  )\n\n  return (\n    <HStack gap=\"4px\">\n      {list.map((item: any) => (\n        <FromCoinItem\n          key={item.coin_type}\n          coin={item}\n          amount={item.amountIn}\n          isActive={item.coin_type === currentCoinType}\n          onClick={handleChangeCoinType}\n        />\n      ))}\n    </HStack>\n  )\n}\n\nfunction FromCoinItem({ coin, amount, isActive, onClick }: { coin: Token; amount: string; isActive: boolean; onClick: (coinType: string) => void }) {\n  const handleClick = useCallback(() => {\n    onClick(coin.coin_type)\n  }, [onClick, coin.coin_type])\n\n  return (\n    <HStack\n      gap=\"0px\"\n      borderRadius=\"16px\"\n      border=\"1px solid\"\n      borderColor={isActive ? 'primary' : '#262626'}\n      h=\"32px\"\n      p=\"4px\"\n      bg={isActive ? 'primary_opacity.10' : 'transparent'}\n      _hover={{\n        borderColor: 'primary'\n      }}\n      cursor=\"pointer\"\n      onClick={handleClick}\n    >\n      <SingleCoinImage imageUrl={coin?.logo_url} w=\"24px\" h=\"24px\" borderRadius=\"12px\" />\n      {isActive && (\n        <HStack gap=\"4px\" p=\"0px 4px\" pr=\"8px\">\n          <Text fontSize=\"14px\" fontWeight=\"500\" color=\"text_caption\">\n            {addComma(amount || '0')}\n          </Text>\n          <Text fontSize=\"14px\" fontWeight=\"500\" color=\"primary_gray\">\n            {coin?.symbol}\n          </Text>\n        </HStack>\n      )}\n    </HStack>\n  )\n}\n\nexport default RoutesModal\n","import { aggregatorStatusPath } from '@/apis/path'\nimport { useFetch } from '@cetus/hooks'\nimport useWebConfigStore from '@cetus/stores/src/useWebConfigStore'\n\nexport default function useGetRouterConfig() {\n  const { fetchByApi } = useFetch()\n  const { providers: storeProviders, setProviders, setProvidersLoading, providersLoading } = useWebConfigStore()\n\n  /**\n   * 获取router配置信息\n   * TODO 每次打开调用一次？\n   */\n  const fetchRouterConfig = async () => {\n    try {\n      setProvidersLoading(storeProviders.length === 1)\n      const res = await fetchByApi(aggregatorStatusPath, 'GET')\n      const { providers } = res\n      if (providers && providers.length > 0) {\n        setProviders(providers)\n      }\n      console.log('🚀 ~ file: useGetRouterConfig.ts:13 ~ fetchRouterConfig ~ res:', res)\n    } catch (error) {\n      console.log('🚀 ~ file: useGetRouterConfig.ts:18 ~ fetchRouterConfig ~ error:', error)\n    } finally {\n      setProvidersLoading(false)\n    }\n  }\n\n  return {\n    fetchRouterConfig,\n    providersLoading\n  }\n}\n"],"names":["CLONE_DEEP_FLAG","CLONE_SYMBOLS_FLAG","cloneDeep","value","baseClone","routerComWidth","blockWidth","blockGap","gapWithLine","blockPadding","columeBlockSpace","targetCoinInfoHeight","fromToTargetBlockPaddingTopAndBottom","fromToTargetTitleHeight","fromToTargetMrTop","providerRowHeight","minTop","zStartWidth","routerComGap","pathToGap","useSwapRouter","routerData","originFromCoinType","originToCoinType","newFormatSwapRouter","setNewFormatSwapRouter","useState","nodes","setgNodes","edges","setEdges","panelHeight","setPanelHeight","fromCoin","toCoin","useSwapStore","allProviders","setAllProviders","resultColumes","setResultColumes","getNodeColumeOptimized","paths","fromCoinType","targetCoinType","maxDepth","allNodes","path","columns","column0","firstColNodes","target","hasOtherFroms","otherPath","notCollectInfirst","allTargets","_a","item","fromGroups","fromKey","providerFeeRateMap","provider","feeRate","key","existing","d","column1","middleNodes","node","column2","targetFromGroups","getNodes","nodeColume","columeNum","columeComWidth","columeComMarginWithRouterCom","nodesMap","orderedNodeColume","nodeHeights","col","colIndex","block","nodeKey","height","getBlockHeight","currentTop","blockHeight","firstCol","secondCol","hasFromCoinToSecondCol","secondBlock","sortedFirstCol","totalAmountIn","sum","a","b","secondColTop","thirdCol","_b","firstColAnalysis","secondColHaveEqualTarget","hasDirectToTarget","hasConnectionToSecond","secondTarget","secondColTargets","priority","singleTarget","aAmountIn","hasFromCoinToTarget","thirdBlock","firstColStartTop","fromCoinSecondColBlock","secondBlockKey","secondBlockHeight","currentColume1Top","index","secondColOrder","fromCoinSecondCol","firstItem","secondColStartTop","hasFirstColToTargetNum","_c","currentColume2Top","currentColume3Top","generateNodePercentages","nodePercentages","fromCoinTypeTargets","originalTarget","totalFromAmountIn","rawPercents","amountIn","rawPercent","fixDown","rawAjuestPercents","adjustTo100","fromPercent","hasSameTargetInSecondCol","blockTarget","thirdColTargets","thirdTarget","findNodeByColumnAndCoinType","coinType","getEdges","_d","targetNode","_f","_e","lastBlock","currentNode","nodeOutgoingCounts","nodeOutgoingIndices","fromConnections","fromToken","targetData","fromNode","prevColIndex","fromNodeId","currentCount","fromCenterY","needZigzag","currentOutgoingIndex","firstColFirstNode","foundHorizontalPosition","y","_g","_i","_h","_k","_j","_m","_l","totalOutgoingCount","spacing","startY","availableHeight","step","adjustedFromY","_n","specialFromX","specialFromY","maxColumnIndex","lastColumnNodes","lastColumnNode","fromY","getPanelHeight","maxBottom","toFormatSwapRouter","toLongCoinType","adjustedNodes","targets","getTokenMap","getTokenListInfo","useGetToken","tokenMap","setTokenMap","coinTypeList","res","useDeepCompareEffect","getAllProviders","providers","list","fromEntries","from","items","i","ScamsAlert","scamsText","jsxs","VStack","HStack","jsx","Icon","Text","Box","HighlightText","OverView","children","loading","isSwapWidget","isApp","useWindowWidth","allProviderFilter","setAllProviderFilter","useEffect","processedGroups","filteredProviders","groupDex","findGroupDex","Skeleton","SingleCoinImage","AggregatorDexMap","Popover","PopoverTrigger","Portal","PopoverContent","PopoverBody","findDisplayName","pathStrokeWidth","V3Router","data","config","isWidget","containerRef","useRef","defaultConfig","displayNodes","useMemo","targetItem","targetInfo","keys","fromInfo","title","textEllipses","totalAmountOut","listItem","amountOut","tempPercents","percent","getPercentage","formatFeeRate","SvgEdges","DrawBlock","checkLineRectIntersection","lineX1","lineY1","lineX2","lineY2","rectLeft","rectTop","rectWidth","rectHeight","rectRight","rectBottom","lineLeft","lineRight","lineTop","lineBottom","edge","linesIntersect","x1","y1","x2","y2","x3","y3","x4","y4","denom","t","u","generateSmartPathWithNodeConnection","fromX","toX","toY","toBlockHeight","targetNodeWidth","isStart","allEdges","searchStep","nodePadding","arrowOffset","checkLineIntersection","checkHorizontalConnection","sourceY","sourceTop","sourceNode","sourceBottom","targetTop","targetBottom","overlapTop","overlapBottom","targetCenterY","sourceOutgoingEdges","e","sourceCenterY","targetCenterX","targetBottomY","sourceCenterX","downY","svgRef","firstColumnEdges","lastFirstColumnEdge","maxEdge","currentEdge","lastColumnEdges","lastThirdColumnEdge","leftConnectionPath","rightConnectionPath","idx","labelX","labelY","segment","segmentIdx","firstSegment","deltaX","deltaY","pathParts","actualStartX","actualStartY","isDownThenHorizontal","startCoords","secondSegment","firstCoords","secondCoords","firstY","secondY","textContent","textWidth","backgroundWidth","backgroundHeight","backgroundX","backgroundY","TargetBlock","TokenToolTip","PathItem","PathToolTip","getExplorerUrl","useExplorer","CoinPairImage","Center","AddressCopyLink","CetusTooltip","RoutesModal","isOpen","onClose","fromAmount","toAmount","mergeSwapData","allRoutes","currentIndex","isMergeSwap","currentMergeSwapIndex","setCurrentMergeSwapIndex","mergeFromCoinList","setMergeFromCoinList","stableAllRoutes","handleChangeMergeSwapIndex","fixCoinType","v3RouterData","currentAllProviders","getTokenListInfoRef","mergeSwapToCoin","setMergeSwapToCoin","toCoinType","coinListData","bnToAmount","error","currentToCoin","currentToAmount","Modal","ModalOverlay","ModalContent","ModalHeader","ModalCloseButton","ModalBody","FromCoinTabs","addComma","defaultIndex","onChange","currentCoinType","handleChangeCoinType","useCallback","FromCoinItem","coin","amount","isActive","onClick","handleClick","useGetRouterConfig","fetchByApi","useFetch","storeProviders","setProviders","setProvidersLoading","providersLoading","useWebConfigStore","aggregatorStatusPath"],"mappings":"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","x_google_ignoreList":[0]}