{"version":3,"file":"TransportWebHID-CTJm1suJ.js","sources":["../../../../node_modules/.pnpm/@ledgerhq+hw-transport@6.31.12/node_modules/@ledgerhq/hw-transport/lib-es/Transport.js","../../../../node_modules/.pnpm/@ledgerhq+devices@8.6.1/node_modules/@ledgerhq/devices/lib-es/hid-framing.js","../../../../node_modules/.pnpm/@ledgerhq+devices@8.6.1/node_modules/@ledgerhq/devices/lib-es/index.js","../../../../node_modules/.pnpm/@ledgerhq+hw-transport-webhid@6.30.8/node_modules/@ledgerhq/hw-transport-webhid/lib-es/TransportWebHID.js"],"sourcesContent":["import EventEmitter from \"events\";\nimport { TransportRaceCondition, TransportError, StatusCodes, getAltStatusMessage, TransportStatusError, } from \"@ledgerhq/errors\";\nimport { LocalTracer } from \"@ledgerhq/logs\";\nexport { TransportError, TransportStatusError, StatusCodes, getAltStatusMessage };\nconst DEFAULT_LOG_TYPE = \"transport\";\n/**\n * The Transport class defines a generic interface for communicating with a Ledger hardware wallet.\n * There are different kind of transports based on the technology (channels like U2F, HID, Bluetooth, Webusb) and environment (Node, Web,...).\n * It is an abstract class that needs to be implemented.\n */\nexport default class Transport {\n    exchangeTimeout = 30000;\n    unresponsiveTimeout = 15000;\n    deviceModel = null;\n    tracer;\n    constructor({ context, logType } = {}) {\n        this.tracer = new LocalTracer(logType ?? DEFAULT_LOG_TYPE, context);\n    }\n    /**\n     * Check if the transport is supported on the current platform/browser.\n     * @returns {Promise<boolean>} A promise that resolves with a boolean indicating support.\n     */\n    static isSupported;\n    /**\n     * List all available descriptors for the transport.\n     * For a better granularity, checkout `listen()`.\n     *\n     * @returns {Promise<Array<any>>} A promise that resolves with an array of descriptors.\n     * @example\n     * TransportFoo.list().then(descriptors => ...)\n     */\n    static list;\n    /**\n     * Listen for device events for the transport. The method takes an observer of DescriptorEvent and returns a Subscription.\n     * A DescriptorEvent is an object containing a \"descriptor\" and a \"type\" field. The \"type\" field can be \"add\" or \"remove\", and the \"descriptor\" field can be passed to the \"open\" method.\n     * The \"listen\" method will first emit all currently connected devices and then will emit events as they occur, such as when a USB device is plugged in or a Bluetooth device becomes discoverable.\n     * @param {Observer<DescriptorEvent<any>>} observer - An object with \"next\", \"error\", and \"complete\" functions, following the observer pattern.\n     * @returns {Subscription} A Subscription object on which you can call \".unsubscribe()\" to stop listening to descriptors.\n     * @example\n    const sub = TransportFoo.listen({\n    next: e => {\n      if (e.type===\"add\") {\n        sub.unsubscribe();\n        const transport = await TransportFoo.open(e.descriptor);\n        ...\n      }\n    },\n    error: error => {},\n    complete: () => {}\n    })\n     */\n    static listen;\n    /**\n     * Attempt to create a Transport instance with a specific descriptor.\n     * @param {any} descriptor - The descriptor to open the transport with.\n     * @param {number} timeout - An optional timeout for the transport connection.\n     * @param {TraceContext} context Optional tracing/log context\n     * @returns {Promise<Transport>} A promise that resolves with a Transport instance.\n     * @example\n    TransportFoo.open(descriptor).then(transport => ...)\n     */\n    static open;\n    /**\n     * Send data to the device using a low level API.\n     * It's recommended to use the \"send\" method for a higher level API.\n     * @param {Buffer} apdu - The data to send.\n     * @param {Object} options - Contains optional options for the exchange function\n     *  - abortTimeoutMs: stop the exchange after a given timeout. Another timeout exists\n     *    to detect unresponsive device (see `unresponsiveTimeout`). This timeout aborts the exchange.\n     * @returns {Promise<Buffer>} A promise that resolves with the response data from the device.\n     */\n    exchange(_apdu, { abortTimeoutMs: _abortTimeoutMs } = {}) {\n        throw new Error(\"exchange not implemented\");\n    }\n    /**\n     * Send apdus in batch to the device using a low level API.\n     * The default implementation is to call exchange for each apdu.\n     * @param {Array<Buffer>} apdus - array of apdus to send.\n     * @param {Observer<Buffer>} observer - an observer that will receive the response of each apdu.\n     * @returns {Subscription} A Subscription object on which you can call \".unsubscribe()\" to stop sending apdus.\n     */\n    exchangeBulk(apdus, observer) {\n        let unsubscribed = false;\n        const unsubscribe = () => {\n            unsubscribed = true;\n        };\n        const main = async () => {\n            if (unsubscribed)\n                return;\n            for (const apdu of apdus) {\n                const r = await this.exchange(apdu);\n                if (unsubscribed)\n                    return;\n                const status = r.readUInt16BE(r.length - 2);\n                if (status !== StatusCodes.OK) {\n                    throw new TransportStatusError(status);\n                }\n                observer.next(r);\n            }\n        };\n        main().then(() => !unsubscribed && observer.complete(), e => !unsubscribed && observer.error(e));\n        return { unsubscribe };\n    }\n    /**\n     * Set the \"scramble key\" for the next data exchanges with the device.\n     * Each app can have a different scramble key and it is set internally during instantiation.\n     * @param {string} key - The scramble key to set.\n     * deprecated This method is no longer needed for modern transports and should be migrated away from.\n     * no @ before deprecated as it breaks documentationjs on version 14.0.2\n     * https://github.com/documentationjs/documentation/issues/1596\n     */\n    setScrambleKey(_key) { }\n    /**\n     * Close the connection with the device.\n     *\n     * Note: for certain transports (hw-transport-node-hid-singleton for ex), once the promise resolved,\n     * the transport instance is actually still cached, and the device is disconnected only after a defined timeout.\n     * But for the consumer of the Transport, this does not matter and it can consider the transport to be closed.\n     *\n     * @returns {Promise<void>} A promise that resolves when the transport is closed.\n     */\n    close() {\n        return Promise.resolve();\n    }\n    _events = new EventEmitter();\n    /**\n     * Listen for an event on the transport instance.\n     * Transport implementations may have specific events. Common events include:\n     * \"disconnect\" : triggered when the transport is disconnected.\n     * @param {string} eventName - The name of the event to listen for.\n     * @param {(...args: Array<any>) => any} cb - The callback function to be invoked when the event occurs.\n     */\n    on(eventName, cb) {\n        this._events.on(eventName, cb);\n    }\n    /**\n     * Stop listening to an event on an instance of transport.\n     */\n    off(eventName, cb) {\n        this._events.removeListener(eventName, cb);\n    }\n    emit(event, ...args) {\n        this._events.emit(event, ...args);\n    }\n    /**\n     * Enable or not logs of the binary exchange\n     */\n    setDebugMode() {\n        console.warn(\"setDebugMode is deprecated. use @ledgerhq/logs instead. No logs are emitted in this anymore.\");\n    }\n    /**\n     * Set a timeout (in milliseconds) for the exchange call. Only some transport might implement it. (e.g. U2F)\n     */\n    setExchangeTimeout(exchangeTimeout) {\n        this.exchangeTimeout = exchangeTimeout;\n    }\n    /**\n     * Define the delay before emitting \"unresponsive\" on an exchange that does not respond\n     */\n    setExchangeUnresponsiveTimeout(unresponsiveTimeout) {\n        this.unresponsiveTimeout = unresponsiveTimeout;\n    }\n    /**\n     * Send data to the device using the higher level API.\n     *\n     * @param {number} cla - The instruction class for the command.\n     * @param {number} ins - The instruction code for the command.\n     * @param {number} p1 - The first parameter for the instruction.\n     * @param {number} p2 - The second parameter for the instruction.\n     * @param {Buffer} data - The data to be sent. Defaults to an empty buffer.\n     * @param {Array<number>} statusList - A list of acceptable status codes for the response. Defaults to [StatusCodes.OK].\n     * @param {Object} options - Contains optional options for the exchange function\n     *  - abortTimeoutMs: stop the send after a given timeout. Another timeout exists\n     *    to detect unresponsive device (see `unresponsiveTimeout`). This timeout aborts the exchange.\n     * @returns {Promise<Buffer>} A promise that resolves with the response data from the device.\n     */\n    send = async (cla, ins, p1, p2, data = Buffer.alloc(0), statusList = [StatusCodes.OK], { abortTimeoutMs } = {}) => {\n        const tracer = this.tracer.withUpdatedContext({ function: \"send\" });\n        if (data.length >= 256) {\n            tracer.trace(\"data.length exceeded 256 bytes limit\", { dataLength: data.length });\n            throw new TransportError(\"data.length exceed 256 bytes limit. Got: \" + data.length, \"DataLengthTooBig\");\n        }\n        tracer.trace(\"Starting an exchange\", { abortTimeoutMs });\n        const response = await this.exchange(\n        // The size of the data is added in 1 byte just before `data`\n        Buffer.concat([Buffer.from([cla, ins, p1, p2]), Buffer.from([data.length]), data]), { abortTimeoutMs });\n        tracer.trace(\"Received response from exchange\");\n        const sw = response.readUInt16BE(response.length - 2);\n        if (!statusList.some(s => s === sw)) {\n            throw new TransportStatusError(sw);\n        }\n        return response;\n    };\n    /**\n     * create() allows to open the first descriptor available or\n     * throw if there is none or if timeout is reached.\n     * This is a light helper, alternative to using listen() and open() (that you may need for any more advanced usecase)\n     * @example\n    TransportFoo.create().then(transport => ...)\n     */\n    static create(openTimeout = 3000, listenTimeout) {\n        return new Promise((resolve, reject) => {\n            let found = false;\n            const sub = this.listen({\n                next: e => {\n                    found = true;\n                    if (sub)\n                        sub.unsubscribe();\n                    if (listenTimeoutId)\n                        clearTimeout(listenTimeoutId);\n                    this.open(e.descriptor, openTimeout).then(resolve, reject);\n                },\n                error: e => {\n                    if (listenTimeoutId)\n                        clearTimeout(listenTimeoutId);\n                    reject(e);\n                },\n                complete: () => {\n                    if (listenTimeoutId)\n                        clearTimeout(listenTimeoutId);\n                    if (!found) {\n                        reject(new TransportError(this.ErrorMessage_NoDeviceFound, \"NoDeviceFound\"));\n                    }\n                },\n            });\n            const listenTimeoutId = listenTimeout\n                ? setTimeout(() => {\n                    sub.unsubscribe();\n                    reject(new TransportError(this.ErrorMessage_ListenTimeout, \"ListenTimeout\"));\n                }, listenTimeout)\n                : null;\n        });\n    }\n    // Blocks other exchange to happen concurrently\n    exchangeBusyPromise;\n    /**\n     * Wrapper to make an exchange \"atomic\" (blocking any other exchange)\n     *\n     * It also handles \"unresponsiveness\" by emitting \"unresponsive\" and \"responsive\" events.\n     *\n     * @param f The exchange job, using the transport to run\n     * @returns a Promise resolving with the output of the given job\n     */\n    async exchangeAtomicImpl(f) {\n        const tracer = this.tracer.withUpdatedContext({\n            function: \"exchangeAtomicImpl\",\n            unresponsiveTimeout: this.unresponsiveTimeout,\n        });\n        if (this.exchangeBusyPromise) {\n            tracer.trace(\"Atomic exchange is already busy\");\n            throw new TransportRaceCondition(\"An action was already pending on the Ledger device. Please deny or reconnect.\");\n        }\n        // Sets the atomic guard\n        let resolveBusy;\n        const busyPromise = new Promise(r => {\n            resolveBusy = r;\n        });\n        this.exchangeBusyPromise = busyPromise;\n        // The device unresponsiveness handler\n        let unresponsiveReached = false;\n        const timeout = setTimeout(() => {\n            tracer.trace(`Timeout reached, emitting Transport event \"unresponsive\"`, {\n                unresponsiveTimeout: this.unresponsiveTimeout,\n            });\n            unresponsiveReached = true;\n            this.emit(\"unresponsive\");\n        }, this.unresponsiveTimeout);\n        try {\n            const res = await f();\n            if (unresponsiveReached) {\n                tracer.trace(\"Device was unresponsive, emitting responsive\");\n                this.emit(\"responsive\");\n            }\n            return res;\n        }\n        finally {\n            tracer.trace(\"Finalize, clearing busy guard\");\n            clearTimeout(timeout);\n            if (resolveBusy)\n                resolveBusy();\n            this.exchangeBusyPromise = null;\n        }\n    }\n    decorateAppAPIMethods(self, methods, scrambleKey) {\n        for (const methodName of methods) {\n            self[methodName] = this.decorateAppAPIMethod(methodName, self[methodName], self, scrambleKey);\n        }\n    }\n    _appAPIlock = null;\n    decorateAppAPIMethod(methodName, f, ctx, scrambleKey) {\n        return async (...args) => {\n            const { _appAPIlock } = this;\n            if (_appAPIlock) {\n                return Promise.reject(new TransportError(\"Ledger Device is busy (lock \" + _appAPIlock + \")\", \"TransportLocked\"));\n            }\n            try {\n                this._appAPIlock = methodName;\n                this.setScrambleKey(scrambleKey);\n                return await f.apply(ctx, args);\n            }\n            finally {\n                this._appAPIlock = null;\n            }\n        };\n    }\n    /**\n     * Sets the context used by the logging/tracing mechanism\n     *\n     * Useful when re-using (cached) the same Transport instance,\n     * but with a new tracing context.\n     *\n     * @param context A TraceContext, that can undefined to reset the context\n     */\n    setTraceContext(context) {\n        this.tracer = this.tracer.withContext(context);\n    }\n    /**\n     * Updates the context used by the logging/tracing mechanism\n     *\n     * The update only overrides the key-value that are already defined in the current context.\n     *\n     * @param contextToAdd A TraceContext that will be added to the current context\n     */\n    updateTraceContext(contextToAdd) {\n        this.tracer.updateContext(contextToAdd);\n    }\n    /**\n     * Gets the tracing context of the transport instance\n     */\n    getTraceContext() {\n        return this.tracer.getContext();\n    }\n    static ErrorMessage_ListenTimeout = \"No Ledger device found (timeout)\";\n    static ErrorMessage_NoDeviceFound = \"No Ledger device found\";\n}\n//# sourceMappingURL=Transport.js.map","import { TransportError } from \"@ledgerhq/errors\";\nconst Tag = 0x05;\nfunction asUInt16BE(value) {\n    const b = Buffer.alloc(2);\n    b.writeUInt16BE(value, 0);\n    return b;\n}\nconst initialAcc = {\n    data: Buffer.alloc(0),\n    dataLength: 0,\n    sequence: 0,\n};\n/**\n * Object to handle HID frames (encoding and decoding)\n *\n * @param channel\n * @param packetSize The HID protocol packet size in bytes (usually 64)\n */\nconst createHIDframing = (channel, packetSize) => {\n    return {\n        /**\n         * Frames/encodes an APDU message into HID USB packets/frames\n         *\n         * @param apdu The APDU message to send, in a Buffer containing [cla, ins, p1, p2, data length, data(if not empty)]\n         * @returns an array of HID USB frames ready to be sent\n         */\n        makeBlocks(apdu) {\n            // Encodes the APDU length in 2 bytes before the APDU itself.\n            // The length is measured as the number of bytes.\n            // As the size of the APDU `data` should have been added in 1 byte just before `data`,\n            // the minimum size of an APDU is 5 bytes.\n            let data = Buffer.concat([asUInt16BE(apdu.length), apdu]);\n            const blockSize = packetSize - 5;\n            const nbBlocks = Math.ceil(data.length / blockSize);\n            // Fills data with 0-padding\n            data = Buffer.concat([data, Buffer.alloc(nbBlocks * blockSize - data.length + 1).fill(0)]);\n            const blocks = [];\n            for (let i = 0; i < nbBlocks; i++) {\n                const head = Buffer.alloc(5);\n                head.writeUInt16BE(channel, 0);\n                head.writeUInt8(Tag, 2);\n                head.writeUInt16BE(i, 3);\n                // `slice` and not `subarray`: this might not be a Node Buffer, but probably only a Uint8Array\n                const chunk = data.slice(i * blockSize, (i + 1) * blockSize);\n                blocks.push(Buffer.concat([head, chunk]));\n            }\n            return blocks;\n        },\n        /**\n         * Reduces HID USB packets/frames to one response.\n         *\n         * @param acc The value resulting from (accumulating) the previous call of reduceResponse.\n         *   On first call initialized to `initialAcc`. The accumulator enables handling multi-frames messages.\n         * @param chunk Current chunk to reduce into accumulator\n         * @returns An accumulator value updated with the current chunk\n         */\n        reduceResponse(acc, chunk) {\n            let { data, dataLength, sequence } = acc || initialAcc;\n            if (chunk.readUInt16BE(0) !== channel) {\n                throw new TransportError(\"Invalid channel\", \"InvalidChannel\");\n            }\n            if (chunk.readUInt8(2) !== Tag) {\n                throw new TransportError(\"Invalid tag\", \"InvalidTag\");\n            }\n            if (chunk.readUInt16BE(3) !== sequence) {\n                throw new TransportError(\"Invalid sequence\", \"InvalidSequence\");\n            }\n            // Gets the total length of the response from the 1st frame\n            if (!acc) {\n                dataLength = chunk.readUInt16BE(5);\n            }\n            sequence++;\n            // The total length on the 1st frame takes 2 more bytes\n            const chunkData = chunk.slice(acc ? 5 : 7);\n            data = Buffer.concat([data, chunkData]);\n            // Removes any 0 padding\n            if (data.length > dataLength) {\n                data = data.slice(0, dataLength);\n            }\n            return {\n                data,\n                dataLength,\n                sequence,\n            };\n        },\n        /**\n         * Returns the response message that has been reduced from the HID USB frames\n         *\n         * @param acc The accumulator\n         * @returns A Buffer containing the cleaned response message, or null if no response message, or undefined if the\n         *   accumulator is incorrect (message length is not valid)\n         */\n        getReducedResult(acc) {\n            if (acc && acc.dataLength === acc.data.length) {\n                return acc.data;\n            }\n        },\n    };\n};\nexport default createHIDframing;\n//# sourceMappingURL=hid-framing.js.map","import semver from \"semver\";\n/**\n * The USB product IDs will be defined as MMII, encoding a model (MM) and an interface bitfield (II)\n *\n ** Model\n * Ledger Nano S : 0x10\n * Ledger Blue : 0x00\n * Ledger Nano X : 0x40\n *\n ** Interface support bitfield\n * Generic HID : 0x01\n * Keyboard HID : 0x02\n * U2F : 0x04\n * CCID : 0x08\n * WebUSB : 0x10\n */\nexport const IIGenericHID = 0x01;\nexport const IIKeyboardHID = 0x02;\nexport const IIU2F = 0x04;\nexport const IICCID = 0x08;\nexport const IIWebUSB = 0x10;\nexport var DeviceModelId;\n(function (DeviceModelId) {\n    /** Ledger Blue */\n    DeviceModelId[\"blue\"] = \"blue\";\n    /** Ledger Nano S */\n    DeviceModelId[\"nanoS\"] = \"nanoS\";\n    /** Ledger Nano S Plus */\n    DeviceModelId[\"nanoSP\"] = \"nanoSP\";\n    /** Ledger Nano X */\n    DeviceModelId[\"nanoX\"] = \"nanoX\";\n    /** Ledger Stax */\n    DeviceModelId[\"stax\"] = \"stax\";\n    /** Ledger Flex (\"europa\" is the internal name) */\n    DeviceModelId[\"europa\"] = \"europa\";\n    /** Apex */\n    DeviceModelId[\"apex\"] = \"apex\";\n})(DeviceModelId || (DeviceModelId = {}));\nconst devices = {\n    [DeviceModelId.blue]: {\n        id: DeviceModelId.blue,\n        productName: \"Ledger Blue\",\n        productIdMM: 0x00,\n        legacyUsbProductId: 0x0000,\n        usbOnly: true,\n        memorySize: 480 * 1024,\n        masks: [0x31000000, 0x31010000],\n        getBlockSize: (_firwareVersion) => 4 * 1024,\n    },\n    [DeviceModelId.nanoS]: {\n        id: DeviceModelId.nanoS,\n        productName: \"Ledger Nano S\",\n        productIdMM: 0x10,\n        legacyUsbProductId: 0x0001,\n        usbOnly: true,\n        memorySize: 320 * 1024,\n        masks: [0x31100000],\n        getBlockSize: (firmwareVersion) => semver.lt(semver.coerce(firmwareVersion) ?? \"\", \"2.0.0\") ? 4 * 1024 : 2 * 1024,\n    },\n    [DeviceModelId.nanoX]: {\n        id: DeviceModelId.nanoX,\n        productName: \"Ledger Nano X\",\n        productIdMM: 0x40,\n        legacyUsbProductId: 0x0004,\n        usbOnly: false,\n        memorySize: 2 * 1024 * 1024,\n        masks: [0x33000000],\n        getBlockSize: (_firwareVersion) => 4 * 1024,\n        bluetoothSpec: [\n            {\n                serviceUuid: \"13d63400-2c97-0004-0000-4c6564676572\",\n                notifyUuid: \"13d63400-2c97-0004-0001-4c6564676572\",\n                writeUuid: \"13d63400-2c97-0004-0002-4c6564676572\",\n                writeCmdUuid: \"13d63400-2c97-0004-0003-4c6564676572\",\n            },\n        ],\n    },\n    [DeviceModelId.nanoSP]: {\n        id: DeviceModelId.nanoSP,\n        productName: \"Ledger Nano S Plus\",\n        productIdMM: 0x50,\n        legacyUsbProductId: 0x0005,\n        usbOnly: true,\n        memorySize: 1533 * 1024,\n        masks: [0x33100000],\n        getBlockSize: (_firmwareVersion) => 32,\n    },\n    [DeviceModelId.apex]: {\n        id: DeviceModelId.apex,\n        productName: \"Ledger Apex\",\n        productIdMM: 0x80,\n        legacyUsbProductId: 0x0008,\n        usbOnly: false,\n        memorySize: 1533 * 1024,\n        masks: [0x33400000],\n        getBlockSize: (_firmwareVersion) => 32,\n        bluetoothSpec: [\n            {\n                serviceUuid: \"13d63400-2c97-8004-0000-4c6564676572\",\n                notifyUuid: \"13d63400-2c97-8004-0001-4c6564676572\",\n                writeUuid: \"13d63400-2c97-8004-0002-4c6564676572\",\n                writeCmdUuid: \"13d63400-2c97-8004-0003-4c6564676572\",\n            },\n        ],\n    },\n    [DeviceModelId.stax]: {\n        id: DeviceModelId.stax,\n        productName: \"Ledger Stax\",\n        productIdMM: 0x60,\n        legacyUsbProductId: 0x0006,\n        usbOnly: false,\n        memorySize: 1533 * 1024,\n        masks: [0x33200000],\n        getBlockSize: (_firmwareVersion) => 32,\n        bluetoothSpec: [\n            {\n                serviceUuid: \"13d63400-2c97-6004-0000-4c6564676572\",\n                notifyUuid: \"13d63400-2c97-6004-0001-4c6564676572\",\n                writeUuid: \"13d63400-2c97-6004-0002-4c6564676572\",\n                writeCmdUuid: \"13d63400-2c97-6004-0003-4c6564676572\",\n            },\n        ],\n    },\n    [DeviceModelId.europa]: {\n        id: DeviceModelId.europa,\n        productName: \"Ledger Flex\",\n        productIdMM: 0x70,\n        legacyUsbProductId: 0x0007,\n        usbOnly: false,\n        memorySize: 1533 * 1024,\n        masks: [0x33300000],\n        getBlockSize: (_firmwareVersion) => 32,\n        bluetoothSpec: [\n            {\n                serviceUuid: \"13d63400-2c97-3004-0000-4c6564676572\",\n                notifyUuid: \"13d63400-2c97-3004-0001-4c6564676572\",\n                writeUuid: \"13d63400-2c97-3004-0002-4c6564676572\",\n                writeCmdUuid: \"13d63400-2c97-3004-0003-4c6564676572\",\n            },\n        ],\n    },\n};\nconst productMap = {\n    Blue: DeviceModelId.blue,\n    \"Nano S\": DeviceModelId.nanoS,\n    \"Nano S Plus\": DeviceModelId.nanoSP,\n    \"Nano X\": DeviceModelId.nanoX,\n    Stax: DeviceModelId.stax,\n    Europa: DeviceModelId.europa,\n};\nconst devicesList = Object.values(devices);\n/**\n *\n */\nexport const ledgerUSBVendorId = 0x2c97;\n/**\n *\n */\nexport const getDeviceModel = (id) => {\n    const info = devices[id];\n    if (!info)\n        throw new Error(\"device '\" + id + \"' does not exist\");\n    return info;\n};\n/**\n * Given a `targetId`, return the deviceModel associated to it,\n * based on the first two bytes.\n */\nexport const identifyTargetId = (targetId) => {\n    const deviceModel = devicesList.find(({ masks }) => masks.find(mask => (targetId & 0xffff0000) === mask));\n    return deviceModel;\n};\n/**\n * From a given USB product id, return the deviceModel associated to it.\n *\n * The mapping from the product id is only based on the 2 most significant bytes.\n * For example, Stax is defined with a product id of 0x60ii, a product id 0x6011 would be mapped to it.\n */\nexport const identifyUSBProductId = (usbProductId) => {\n    const legacy = devicesList.find(d => d.legacyUsbProductId === usbProductId);\n    if (legacy)\n        return legacy;\n    const mm = usbProductId >> 8;\n    const deviceModel = devicesList.find(d => d.productIdMM === mm);\n    return deviceModel;\n};\nexport const identifyProductName = (productName) => {\n    const deviceModel = devicesList.find(d => d.id === productMap[productName]);\n    return deviceModel;\n};\nconst bluetoothServices = [];\nconst serviceUuidToInfos = {};\nfor (const id in devices) {\n    const deviceModel = devices[id];\n    const { bluetoothSpec } = deviceModel;\n    if (bluetoothSpec) {\n        for (let i = 0; i < bluetoothSpec.length; i++) {\n            const spec = bluetoothSpec[i];\n            bluetoothServices.push(spec.serviceUuid);\n            serviceUuidToInfos[spec.serviceUuid] = serviceUuidToInfos[spec.serviceUuid.replace(/-/g, \"\")] = {\n                deviceModel,\n                ...spec,\n            };\n        }\n    }\n}\n/**\n *\n */\nexport const getBluetoothServiceUuids = () => bluetoothServices;\n/**\n *\n */\nexport const getInfosForServiceUuid = (uuid) => serviceUuidToInfos[uuid.toLowerCase()];\n//# sourceMappingURL=index.js.map","import Transport from \"@ledgerhq/hw-transport\";\nimport hidFraming from \"@ledgerhq/devices/hid-framing\";\nimport { identifyUSBProductId, ledgerUSBVendorId } from \"@ledgerhq/devices\";\nimport { log } from \"@ledgerhq/logs\";\nimport { TransportOpenUserCancelled, DisconnectedDeviceDuringOperation, DisconnectedDevice, TransportError, } from \"@ledgerhq/errors\";\nconst ledgerDevices = [\n    {\n        vendorId: ledgerUSBVendorId,\n    },\n];\nconst isSupported = () => Promise.resolve(!!(window.navigator && window.navigator.hid));\nconst getHID = () => {\n    // $FlowFixMe\n    const { hid } = navigator;\n    if (!hid)\n        throw new TransportError(\"navigator.hid is not supported\", \"HIDNotSupported\");\n    return hid;\n};\nasync function requestLedgerDevices() {\n    const device = await getHID().requestDevice({\n        filters: ledgerDevices,\n    });\n    if (Array.isArray(device))\n        return device;\n    return [device];\n}\nasync function getLedgerDevices() {\n    const devices = await getHID().getDevices();\n    return devices.filter(d => d.vendorId === ledgerUSBVendorId);\n}\nasync function getFirstLedgerDevice() {\n    const existingDevices = await getLedgerDevices();\n    if (existingDevices.length > 0)\n        return existingDevices[0];\n    const devices = await requestLedgerDevices();\n    return devices[0];\n}\n/**\n * WebHID Transport implementation\n * @example\n * import TransportWebHID from \"@ledgerhq/hw-transport-webhid\";\n * ...\n * TransportWebHID.create().then(transport => ...)\n */\nexport default class TransportWebHID extends Transport {\n    device;\n    deviceModel;\n    channel = Math.floor(Math.random() * 0xffff);\n    packetSize = 64;\n    constructor(device) {\n        super();\n        this.device = device;\n        this.deviceModel =\n            typeof device.productId === \"number\" ? identifyUSBProductId(device.productId) : undefined;\n        device.addEventListener(\"inputreport\", this.onInputReport);\n    }\n    inputs = [];\n    inputCallback;\n    read = () => {\n        if (this.inputs.length) {\n            return Promise.resolve(this.inputs.shift());\n        }\n        return new Promise(success => {\n            this.inputCallback = success;\n        });\n    };\n    onInputReport = (e) => {\n        const buffer = Buffer.from(e.data.buffer);\n        if (this.inputCallback) {\n            this.inputCallback(buffer);\n            this.inputCallback = null;\n        }\n        else {\n            this.inputs.push(buffer);\n        }\n    };\n    /**\n     * Check if WebUSB transport is supported.\n     */\n    static isSupported = isSupported;\n    /**\n     * List the WebUSB devices that was previously authorized by the user.\n     */\n    static list = getLedgerDevices;\n    /**\n     * Actively listen to WebUSB devices and emit ONE device\n     * that was either accepted before, if not it will trigger the native permission UI.\n     *\n     * Important: it must be called in the context of a UI click!\n     */\n    static listen = (observer) => {\n        let unsubscribed = false;\n        getFirstLedgerDevice().then(device => {\n            if (!device) {\n                observer.error(new TransportOpenUserCancelled(\"Access denied to use Ledger device\"));\n            }\n            else if (!unsubscribed) {\n                const deviceModel = typeof device.productId === \"number\"\n                    ? identifyUSBProductId(device.productId)\n                    : undefined;\n                observer.next({\n                    type: \"add\",\n                    descriptor: device,\n                    deviceModel,\n                });\n                observer.complete();\n            }\n        }, error => {\n            observer.error(new TransportOpenUserCancelled(error.message));\n        });\n        function unsubscribe() {\n            unsubscribed = true;\n        }\n        return {\n            unsubscribe,\n        };\n    };\n    /**\n     * Similar to create() except it will always display the device permission (even if some devices are already accepted).\n     */\n    static async request() {\n        const [device] = await requestLedgerDevices();\n        return TransportWebHID.open(device);\n    }\n    /**\n     * Similar to create() except it will never display the device permission (it returns a Promise<?Transport>, null if it fails to find a device).\n     */\n    static async openConnected() {\n        const devices = await getLedgerDevices();\n        if (devices.length === 0)\n            return null;\n        return TransportWebHID.open(devices[0]);\n    }\n    /**\n     * Create a Ledger transport with a HIDDevice\n     */\n    static async open(device) {\n        await device.open();\n        const transport = new TransportWebHID(device);\n        const onDisconnect = e => {\n            if (device === e.device) {\n                getHID().removeEventListener(\"disconnect\", onDisconnect);\n                transport._emitDisconnect(new DisconnectedDevice());\n            }\n        };\n        getHID().addEventListener(\"disconnect\", onDisconnect);\n        return transport;\n    }\n    _disconnectEmitted = false;\n    _emitDisconnect = (e) => {\n        if (this._disconnectEmitted)\n            return;\n        this._disconnectEmitted = true;\n        this.emit(\"disconnect\", e);\n    };\n    /**\n     * Release the transport device\n     */\n    async close() {\n        await this.exchangeBusyPromise;\n        this.device.removeEventListener(\"inputreport\", this.onInputReport);\n        await this.device.close();\n    }\n    /**\n     * Exchange with the device using APDU protocol.\n     * @param apdu\n     * @returns a promise of apdu response\n     */\n    exchange = async (apdu) => {\n        const b = await this.exchangeAtomicImpl(async () => {\n            const { channel, packetSize } = this;\n            log(\"apdu\", \"=> \" + apdu.toString(\"hex\"));\n            const framing = hidFraming(channel, packetSize);\n            // Write...\n            const blocks = framing.makeBlocks(apdu);\n            for (let i = 0; i < blocks.length; i++) {\n                await this.device.sendReport(0, blocks[i]);\n            }\n            // Read...\n            let result;\n            let acc;\n            while (!(result = framing.getReducedResult(acc))) {\n                try {\n                    const buffer = await this.read();\n                    acc = framing.reduceResponse(acc, buffer);\n                }\n                catch (e) {\n                    if (e instanceof TransportError && e.id === \"InvalidChannel\") {\n                        // this can happen if the device is connected\n                        // on a different channel (like another app)\n                        // in this case we just filter out the event\n                        continue;\n                    }\n                    throw e;\n                }\n            }\n            log(\"apdu\", \"<= \" + result.toString(\"hex\"));\n            return result;\n        }).catch(e => {\n            if (e && e.message && e.message.includes(\"write\")) {\n                this._emitDisconnect(e);\n                throw new DisconnectedDeviceDuringOperation(e.message);\n            }\n            throw e;\n        });\n        return b;\n    };\n    setScrambleKey() { }\n}\n//# sourceMappingURL=TransportWebHID.js.map"],"names":["DEFAULT_LOG_TYPE","Transport","context","logType","__publicField","EventEmitter","cla","ins","p1","p2","data","Buffer","statusList","StatusCodes","abortTimeoutMs","tracer","TransportError","response","sw","s","TransportStatusError","LocalTracer","_apdu","_abortTimeoutMs","apdus","observer","unsubscribed","unsubscribe","apdu","r","status","e","_key","eventName","cb","event","args","exchangeTimeout","unresponsiveTimeout","openTimeout","listenTimeout","resolve","reject","found","sub","listenTimeoutId","f","TransportRaceCondition","resolveBusy","busyPromise","unresponsiveReached","timeout","res","self","methods","scrambleKey","methodName","ctx","_appAPIlock","contextToAdd","Tag","asUInt16BE","value","b","initialAcc","createHIDframing","channel","packetSize","blockSize","nbBlocks","blocks","i","head","chunk","acc","dataLength","sequence","chunkData","DeviceModelId","devices","_firwareVersion","firmwareVersion","semver","_firmwareVersion","devicesList","ledgerUSBVendorId","identifyUSBProductId","usbProductId","legacy","d","mm","bluetoothServices","serviceUuidToInfos","id","deviceModel","bluetoothSpec","spec","ledgerDevices","isSupported","getHID","hid","requestLedgerDevices","device","getLedgerDevices","getFirstLedgerDevice","existingDevices","_TransportWebHID","success","buffer","log","framing","hidFraming","result","DisconnectedDeviceDuringOperation","transport","onDisconnect","DisconnectedDevice","TransportOpenUserCancelled","error","TransportWebHID"],"mappings":"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","x_google_ignoreList":[0,1,2,3]}